{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Implementation of a simulation to visualize how the range depends on the angle of projection. Step 1: Theoretical Foundation Derivation of Governing Equations A projectile is subject to uniform acceleration due to gravity and follows a parabolic trajectory. We assume: The projectile is launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) . The only force acting on it is gravity (ignoring air resistance). The motion is decomposed into horizontal and vertical components. Equations of Motion Using kinematic equations: Horizontal Motion (constant velocity, since no horizontal acceleration): \\[ x = v_0 \\cos(\\theta) t \\] Vertical Motion (accelerated motion under gravity): $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: - \\( g \\) is the gravitational acceleration ( \\( 9.81 \\, m/s^2 \\) ). - \\( t \\) is the time elapsed. Time of Flight The time \\( T \\) when the projectile lands back on the ground ( \\( y = 0 \\) ) is found by solving: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2} g T^2 \\] Factoring out \\( T \\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Range of the Projectile The range \\( R \\) is the total horizontal distance traveled before hitting the ground: \\[ R = v_0 \\cos(\\theta) T \\] Substituting \\( T \\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Observations: - The range is maximized when \\( \\sin(2\\theta) \\) is maximum, which occurs at \\( 2\\theta = 90^\\circ \\) (i.e., \\( \\theta = 45^\\circ \\) ). - The range is symmetric around \\( 45^\\circ \\) , meaning that an angle of \\( 30^\\circ \\) and \\( 60^\\circ \\) will give the same range. Step 2: Analysis of the Range The range depends on: Initial Velocity \\(v_0\\) : Higher \\( v_0 \\) increases the range quadratically. Angle of Projection \\(\\theta\\) : The function \\( \\sin(2\\theta) \\) determines the shape of the range curve. Gravitational Acceleration \\(g\\) : Stronger gravity reduces the range. We will visualize how the range varies with \\( \\theta \\) for different \\( v_0 \\) values. Step 3: Computational Implementation Simulates projectile motion. Plots the range as a function of the angle \\( \\theta \\) . Explores different values of \\( v_0 \\) . Here is the plot showing the range of a projectile as a function of the launch angle for different initial velocities. Key Observations: The range follows a symmetric pattern with a peak at 45\u00b0 , confirming our theoretical derivation. The higher the initial velocity \\( v_0 \\) , the greater the range , as expected since range depends on \\( v_0^2 \\) . The function \\( R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) ensures that angles \\( \\theta \\) and \\( 90\u00b0 - \\theta \\) result in the same range , e.g., 30\u00b0 and 60\u00b0 produce identical distances . Step 4: Discussion on Model Limitations & Real-World Applications While the model is useful for idealized projectile motion , real-world scenarios involve: Air Resistance \u2013 Reduces range significantly, especially for high velocities. Wind Effects \u2013 Can increase or decrease range depending on direction. Uneven Terrain \u2013 Landing heights vary, affecting the actual range. Spin Effects \u2013 In sports, spin affects trajectory via the Magnus force (e.g., football or baseball). Practical Applications Sports Science : Optimizing angles for maximum shot distance (e.g., golf, football, basketball). Military Applications : Calculating artillery or missile trajectories. Engineering & Physics : Understanding knowledge in robotics, aerospace, and mechanical systems.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection Implementation of a simulation to visualize how the range depends on the angle of projection.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-1-theoretical-foundation","text":"","title":"Step 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-governing-equations","text":"A projectile is subject to uniform acceleration due to gravity and follows a parabolic trajectory. We assume: The projectile is launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) . The only force acting on it is gravity (ignoring air resistance). The motion is decomposed into horizontal and vertical components.","title":"Derivation of Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Using kinematic equations: Horizontal Motion (constant velocity, since no horizontal acceleration): \\[ x = v_0 \\cos(\\theta) t \\] Vertical Motion (accelerated motion under gravity): $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2 $$ where: - \\( g \\) is the gravitational acceleration ( \\( 9.81 \\, m/s^2 \\) ). - \\( t \\) is the time elapsed.","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"The time \\( T \\) when the projectile lands back on the ground ( \\( y = 0 \\) ) is found by solving: \\[ 0 = v_0 \\sin(\\theta) T - \\frac{1}{2} g T^2 \\] Factoring out \\( T \\) : \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"The range \\( R \\) is the total horizontal distance traveled before hitting the ground: \\[ R = v_0 \\cos(\\theta) T \\] Substituting \\( T \\) : \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Observations: - The range is maximized when \\( \\sin(2\\theta) \\) is maximum, which occurs at \\( 2\\theta = 90^\\circ \\) (i.e., \\( \\theta = 45^\\circ \\) ). - The range is symmetric around \\( 45^\\circ \\) , meaning that an angle of \\( 30^\\circ \\) and \\( 60^\\circ \\) will give the same range.","title":"Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-2-analysis-of-the-range","text":"The range depends on: Initial Velocity \\(v_0\\) : Higher \\( v_0 \\) increases the range quadratically. Angle of Projection \\(\\theta\\) : The function \\( \\sin(2\\theta) \\) determines the shape of the range curve. Gravitational Acceleration \\(g\\) : Stronger gravity reduces the range. We will visualize how the range varies with \\( \\theta \\) for different \\( v_0 \\) values.","title":"Step 2: Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-3-computational-implementation","text":"Simulates projectile motion. Plots the range as a function of the angle \\( \\theta \\) . Explores different values of \\( v_0 \\) . Here is the plot showing the range of a projectile as a function of the launch angle for different initial velocities.","title":"Step 3: Computational Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"The range follows a symmetric pattern with a peak at 45\u00b0 , confirming our theoretical derivation. The higher the initial velocity \\( v_0 \\) , the greater the range , as expected since range depends on \\( v_0^2 \\) . The function \\( R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) ensures that angles \\( \\theta \\) and \\( 90\u00b0 - \\theta \\) result in the same range , e.g., 30\u00b0 and 60\u00b0 produce identical distances .","title":"Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#step-4-discussion-on-model-limitations-real-world-applications","text":"While the model is useful for idealized projectile motion , real-world scenarios involve: Air Resistance \u2013 Reduces range significantly, especially for high velocities. Wind Effects \u2013 Can increase or decrease range depending on direction. Uneven Terrain \u2013 Landing heights vary, affecting the actual range. Spin Effects \u2013 In sports, spin affects trajectory via the Magnus force (e.g., football or baseball).","title":"Step 4: Discussion on Model Limitations &amp; Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications","text":"Sports Science : Optimizing angles for maximum shot distance (e.g., golf, football, basketball). Military Applications : Calculating artillery or missile trajectories. Engineering & Physics : Understanding knowledge in robotics, aerospace, and mechanical systems.","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum is a nonlinear dynamical system that exhibits simple harmonic motion, resonance, and even chaotic behavior under different conditions. Step 1: Theoretical Foundation 1.1 Governing Differential Equation The motion of a forced damped pendulum is governed by the following equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_0 \\cos(\\omega t) \\] where: - \\( \\theta \\) is the angular displacement. - \\( \\gamma \\) is the damping coefficient (controls energy loss due to friction). - \\( g \\) is gravitational acceleration. - \\( L \\) is the length of the pendulum. - \\( F_0 \\) is the amplitude of the external driving force . - \\( \\omega \\) is the driving frequency . 1.2 Approximate Solution for Small Angles For small oscillations, we use the small-angle approximation : \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = F_0 \\cos(\\omega t) \\] This is a driven damped harmonic oscillator equation , which has well-known solutions in terms of resonance and transient motion . 1.3 Resonance Conditions Resonance occurs when the external driving frequency matches the system's natural frequency : \\[ \\omega \\approx \\omega_0 = \\sqrt{\\frac{g}{L}} \\] If \\( \\gamma \\) (damping) is small, resonance leads to large oscillations . If \\( \\gamma \\) is large, oscillations remain damped. Step 2: Computational Simulation Since the equation is nonlinear , we'll use numerical methods to solve it. We'll integrate the equation using the Runge-Kutta method (RK4) to analyze different behaviors. 2.1 Implementation Plan Define the differential equation as a system of first-order ODEs. Implement numerical integration using the Runge-Kutta method . Explore different values of: Damping coefficient \\( \\gamma \\) . Driving force amplitude \\( F_0 \\) . Driving frequency \\( \\omega \\) . Visualize: Time evolution of \\( \\theta \\) (angular displacement). Phase space plot ( \\(\\theta\\) vs. \\( \\dot{\\theta} \\) ). Poincar\u00e9 section (chaotic behavior analysis). (The plot shows how the pendulum\u2019s angle \\( \\theta(t) \\) changes over time.) (The plot shows the pendulum's velocity vs. angle , forming a closed trajectory.) Simulation Results & Observations Time Evolution of Angular Displacement : - The oscillations exhibit damping but are also influenced by the external periodic force , leading to complex periodic motion. Phase Space Plot ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ) : - This is characteristic of regular oscillations , but under different conditions, this could transition into chaotic motion . Step 3: Exploring Resonance and Chaos Resonance: If we set \\( \\omega = \\omega_0 = \\sqrt{g/L} \\) , we should see amplified oscillations . Chaos: Increasing driving amplitude \\( F_0 \\) significantly can lead to chaotic motion , where the phase space plot becomes highly irregular. Investigating Resonance Conditions Observations Under Resonance Conditions (The oscillations in the plot show a significant increase in amplitude compared to the previous case.) (The plot shows a much wider trajectory, indicating larger velocity variations.) Time Evolution of Angular Displacement : - This confirms that at resonance ( \\(\\omega = \\omega_0\\) ) , the external force adds energy efficiently, amplifying the motion. Phase Space Plot : - The pendulum's motion is more energetic and sustained , as expected in a resonance condition. Key Takeaways on Resonance: Resonance leads to maximum energy absorption , resulting in large oscillations. If damping is low , the system can experience runaway oscillations (dangerous in engineering). In real-world applications , engineers must avoid resonance in buildings, bridges, and aircraft structures to prevent failure. Investigating Chaos (The plot shows irregular, unpredictable oscillations .) (The plot shows a highly irregular trajectory , with no clear repeating patterns.) (The plot is a Poincar\u00e9 section , which samples points at regular time intervals.) Observations Under Chaotic Conditions Time Evolution of Angular Displacement : - Unlike the smooth periodic motion seen before, the pendulum exhibits erratic behavior, a signature of chaotic motion . Phase Space Plot ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) : - This indicates sensitive dependence on initial conditions , a key characteristic of chaos . Poincar\u00e9 Section : - Instead of a single periodic point (as in regular motion), we see a scattered set of points . - This suggests a strange attractor , a hallmark of chaotic dynamics. Key Takeaways on Chaos: Chaos emerges when the external forcing overcomes damping and natural oscillations . Small changes in initial conditions can lead to drastically different outcomes (butterfly effect). Many real-world systems exhibit chaos, such as weather patterns, stock markets, and biological rhythms .","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum The forced damped pendulum is a nonlinear dynamical system that exhibits simple harmonic motion, resonance, and even chaotic behavior under different conditions.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-1-theoretical-foundation","text":"","title":"Step 1: Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-differential-equation","text":"The motion of a forced damped pendulum is governed by the following equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin\\theta = F_0 \\cos(\\omega t) \\] where: - \\( \\theta \\) is the angular displacement. - \\( \\gamma \\) is the damping coefficient (controls energy loss due to friction). - \\( g \\) is gravitational acceleration. - \\( L \\) is the length of the pendulum. - \\( F_0 \\) is the amplitude of the external driving force . - \\( \\omega \\) is the driving frequency .","title":"1.1 Governing Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-approximate-solution-for-small-angles","text":"For small oscillations, we use the small-angle approximation : \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = F_0 \\cos(\\omega t) \\] This is a driven damped harmonic oscillator equation , which has well-known solutions in terms of resonance and transient motion .","title":"1.2 Approximate Solution for Small Angles"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-resonance-conditions","text":"Resonance occurs when the external driving frequency matches the system's natural frequency : \\[ \\omega \\approx \\omega_0 = \\sqrt{\\frac{g}{L}} \\] If \\( \\gamma \\) (damping) is small, resonance leads to large oscillations . If \\( \\gamma \\) is large, oscillations remain damped.","title":"1.3 Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-2-computational-simulation","text":"Since the equation is nonlinear , we'll use numerical methods to solve it. We'll integrate the equation using the Runge-Kutta method (RK4) to analyze different behaviors.","title":"Step 2: Computational Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-implementation-plan","text":"Define the differential equation as a system of first-order ODEs. Implement numerical integration using the Runge-Kutta method . Explore different values of: Damping coefficient \\( \\gamma \\) . Driving force amplitude \\( F_0 \\) . Driving frequency \\( \\omega \\) . Visualize: Time evolution of \\( \\theta \\) (angular displacement). Phase space plot ( \\(\\theta\\) vs. \\( \\dot{\\theta} \\) ). Poincar\u00e9 section (chaotic behavior analysis). (The plot shows how the pendulum\u2019s angle \\( \\theta(t) \\) changes over time.) (The plot shows the pendulum's velocity vs. angle , forming a closed trajectory.)","title":"2.1 Implementation Plan"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#simulation-results-observations","text":"Time Evolution of Angular Displacement : - The oscillations exhibit damping but are also influenced by the external periodic force , leading to complex periodic motion. Phase Space Plot ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ) : - This is characteristic of regular oscillations , but under different conditions, this could transition into chaotic motion .","title":"Simulation Results &amp; Observations"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-3-exploring-resonance-and-chaos","text":"Resonance: If we set \\( \\omega = \\omega_0 = \\sqrt{g/L} \\) , we should see amplified oscillations . Chaos: Increasing driving amplitude \\( F_0 \\) significantly can lead to chaotic motion , where the phase space plot becomes highly irregular.","title":"Step 3: Exploring Resonance and Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-resonance-conditions","text":"","title":"Investigating Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#observations-under-resonance-conditions","text":"(The oscillations in the plot show a significant increase in amplitude compared to the previous case.) (The plot shows a much wider trajectory, indicating larger velocity variations.) Time Evolution of Angular Displacement : - This confirms that at resonance ( \\(\\omega = \\omega_0\\) ) , the external force adds energy efficiently, amplifying the motion. Phase Space Plot : - The pendulum's motion is more energetic and sustained , as expected in a resonance condition.","title":"Observations Under Resonance Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-takeaways-on-resonance","text":"Resonance leads to maximum energy absorption , resulting in large oscillations. If damping is low , the system can experience runaway oscillations (dangerous in engineering). In real-world applications , engineers must avoid resonance in buildings, bridges, and aircraft structures to prevent failure.","title":"Key Takeaways on Resonance:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-chaos","text":"(The plot shows irregular, unpredictable oscillations .) (The plot shows a highly irregular trajectory , with no clear repeating patterns.) (The plot is a Poincar\u00e9 section , which samples points at regular time intervals.)","title":"Investigating Chaos"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#observations-under-chaotic-conditions","text":"Time Evolution of Angular Displacement : - Unlike the smooth periodic motion seen before, the pendulum exhibits erratic behavior, a signature of chaotic motion . Phase Space Plot ( \\(\\theta\\) vs. \\(\\dot{\\theta}\\) ) : - This indicates sensitive dependence on initial conditions , a key characteristic of chaos . Poincar\u00e9 Section : - Instead of a single periodic point (as in regular motion), we see a scattered set of points . - This suggests a strange attractor , a hallmark of chaotic dynamics.","title":"Observations Under Chaotic Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#key-takeaways-on-chaos","text":"Chaos emerges when the external forcing overcomes damping and natural oscillations . Small changes in initial conditions can lead to drastically different outcomes (butterfly effect). Many real-world systems exhibit chaos, such as weather patterns, stock markets, and biological rhythms .","title":"Key Takeaways on Chaos:"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Kepler\u2019s Third Law and its Implications 1. Motivation The relationship between the square of the orbital period ( \\( T^2 \\) ) and the cube of the orbital radius ( \\( r^3 \\) ) is elegantly captured in Kepler\u2019s Third Law . This law provides a fundamental connection between orbital motion and gravitational forces, making it a critical concept in celestial mechanics . Understanding this relationship allows us to: - Calculate planetary masses and distances using observational data. - Predict satellite orbits, aiding space exploration. - Explain the motions of celestial bodies in our solar system and beyond. In this document, I will try to implement: 1. Derive Kepler\u2019s Third Law from Newton\u2019s laws. 2. Discuss its implications in astronomy. 3. Simulate orbital motion to verify the law computationally. 4. Analyze real-world cases like the Moon\u2019s orbit and planetary orbits in the Solar System. 2. Derivation of Kepler\u2019s Third Law For a planet orbiting a much more massive central body (e.g., a planet around the Sun or a moon around a planet), Newton\u2019s version of Kepler\u2019s Third Law can be derived from the equation of motion. Newton\u2019s Second Law & Centripetal Force For a body in a circular orbit, the gravitational force acts as the centripetal force : $$ F = \\frac{GMm}{r^2} = m\\frac{v^2}{r} $$ where: - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\( M \\) is the mass of the central body - \\( m \\) is the mass of the orbiting object - \\( r \\) is the orbital radius - \\( v \\) is the orbital velocity Since orbital velocity is related to period \\( T \\) by: $$ v = \\frac{2\\pi r}{T} $$ Substituting this into the force equation: $$ \\frac{GMm}{r^2} = m \\frac{\\left(\\frac{2\\pi r}{T}\\right)^2}{r} $$ Cancel \\( m \\) and rearrange: $$ \\frac{GM}{r^2} = \\frac{4\\pi^2 r}{T^2} $$ Multiplying by \\( r^2 \\) : $$ GM = \\frac{4\\pi^2 r^3}{T^2} $$ Rearrange to find: $$ T^2 = \\frac{4\\pi^2}{GM} r^3 $$ This shows that the square of the orbital period is proportional to the cube of the orbital radius , i.e., $$ T^2 \\propto r^3 $$ 3. Implications for Astronomy Calculating Masses and Distances By measuring the orbital period and radius of a planet or moon, we can determine the mass of the central body . The formula is used extensively in calculating the mass of stars, planets, and even galaxies. Moon\u2019s orbit around Earth \u2014 a perfect real-world application of Kepler\u2019s Third Law and Newtonian gravity. Known Parameters : Mass of Earth : $$ 5.972 \\times 10^{24} \\, \\text{kg} $$ Average distance from Earth to Moon (r) : $$ 3.844 \\times 10^8 \\, \\text{m} $$ Orbital period of the Moon (T) : $$ 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{seconds} $$ Using Kepler\u2019s Third Law We can verify this with the formula: $$ T^2 = \\frac{4\\pi^2 r^3}{GM} $$ Let\u2019s compute the period from scratch and compare it to the known 27.3 days. Result: Moon\u2019s Orbital Period (Calculated) Calculated \\( T \\) : 2,371,877 seconds \u2248 27.45 days Real value: 27.3 days Our calculated value is extremely close to the observed orbital period \u2014 just a slight deviation due to averaging and simplifications (e.g., perfectly circular orbit assumption). This shows how Newton\u2019s version of Kepler\u2019s Third Law accurately predicts real-world motion . By just knowing distance and Earth\u2019s mass , we can compute how long it takes the Moon to orbit ! Exoplanet Discovery Kepler\u2019s Third Law is used to determine the mass of exoplanets based on their orbits around distant stars. 4. Computational Simulation of Circular Orbits We will now implement a Python simulation to verify the \\( T^2 \\propto r^3 \\) relationship numerically. The simulation will: 1. Define gravitational force and motion equations. 2. Simulate circular orbits using Newton\u2019s Laws. 3. Plot the relationship between \\( T^2 \\) and \\( r^3 \\) . Let's implement this: Orbital Simulation and Kepler\u2019s Law Verification 4.1 Scatter Plot of \\((T^2)\\) vs. \\((r^3)\\) with Best-Fit Line - The linear trendline confirms that \\((T^2)\\) is directly proportional to \\((r^3)\\) . - This supports Kepler\u2019s Third Law: \\((T^2 \\propto r^3)\\) . 4.2 Log-Log Plot of \\(T^2\\) vs. \\(r^3\\) - This logarithmic transformation helps visualize power-law relationships. - The straight-line pattern confirms the proportionality. 4.3 Circular Orbits of Multiple Planets at Different Radii - Each orbit represents a planet at increasing distances from the Sun. - According to Kepler\u2019s Law, planets farther away have longer orbital periods . 5. Discussion on Extensions and Real-World Cases Elliptical Orbits For elliptical orbits , Kepler\u2019s Third Law still holds when using the semi-major axis \\( a \\) instead of the orbital radius \\( r \\) . The equation remains: $$ T^2 = \\frac{4\\pi^2}{GM} a^3 $$ where \\( a \\) is the average distance of the object from the central body. Applications in Space Missions Used in designing satellite orbits (e.g., GPS satellites, geostationary orbits). Helps determine orbital transfer times , such as Hohmann transfer orbits used in interplanetary travel. Generalization to Binary Systems In binary star systems, Kepler\u2019s Law is adapted to consider both masses : $$ T^2 = \\frac{4\\pi^2}{G(M_1 + M_2)} a^3 $$ where \\( M_1 \\) and \\( M_2 \\) are the masses of the two orbiting bodies. 6. Conclusion and Further Study Kepler\u2019s Third Law derived, implemented a computational verification, and explored real-world implications. This knowledge is foundational for space exploration, astrophysics, and planetary science! ### Simulation of Hohmann Transfer Orbit What's Happening in the Plot: Blue dashed circle : Earth's orbit (1 AU from the Sun). Red dashed circle : Mars' orbit (~1.524 AU). Green arc : The Hohmann transfer path \u2014the most energy-efficient trajectory to reach Mars. Yellow dot : The Sun at the center of the Solar System. Key Points: The transfer orbit is elliptical , with perihelion at Earth's orbit and aphelion at Mars'. The simulation represents half of the elliptical orbit , which is the typical path a spacecraft takes to go from Earth to Mars.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-and-its-implications","text":"","title":"Kepler\u2019s Third Law and its Implications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-motivation","text":"The relationship between the square of the orbital period ( \\( T^2 \\) ) and the cube of the orbital radius ( \\( r^3 \\) ) is elegantly captured in Kepler\u2019s Third Law . This law provides a fundamental connection between orbital motion and gravitational forces, making it a critical concept in celestial mechanics . Understanding this relationship allows us to: - Calculate planetary masses and distances using observational data. - Predict satellite orbits, aiding space exploration. - Explain the motions of celestial bodies in our solar system and beyond. In this document, I will try to implement: 1. Derive Kepler\u2019s Third Law from Newton\u2019s laws. 2. Discuss its implications in astronomy. 3. Simulate orbital motion to verify the law computationally. 4. Analyze real-world cases like the Moon\u2019s orbit and planetary orbits in the Solar System.","title":"1. Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-derivation-of-keplers-third-law","text":"For a planet orbiting a much more massive central body (e.g., a planet around the Sun or a moon around a planet), Newton\u2019s version of Kepler\u2019s Third Law can be derived from the equation of motion.","title":"2. Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#newtons-second-law-centripetal-force","text":"For a body in a circular orbit, the gravitational force acts as the centripetal force : $$ F = \\frac{GMm}{r^2} = m\\frac{v^2}{r} $$ where: - \\( G \\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\( M \\) is the mass of the central body - \\( m \\) is the mass of the orbiting object - \\( r \\) is the orbital radius - \\( v \\) is the orbital velocity Since orbital velocity is related to period \\( T \\) by: $$ v = \\frac{2\\pi r}{T} $$ Substituting this into the force equation: $$ \\frac{GMm}{r^2} = m \\frac{\\left(\\frac{2\\pi r}{T}\\right)^2}{r} $$ Cancel \\( m \\) and rearrange: $$ \\frac{GM}{r^2} = \\frac{4\\pi^2 r}{T^2} $$ Multiplying by \\( r^2 \\) : $$ GM = \\frac{4\\pi^2 r^3}{T^2} $$ Rearrange to find: $$ T^2 = \\frac{4\\pi^2}{GM} r^3 $$ This shows that the square of the orbital period is proportional to the cube of the orbital radius , i.e., $$ T^2 \\propto r^3 $$","title":"Newton\u2019s Second Law &amp; Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implications-for-astronomy","text":"","title":"3. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-masses-and-distances","text":"By measuring the orbital period and radius of a planet or moon, we can determine the mass of the central body . The formula is used extensively in calculating the mass of stars, planets, and even galaxies.","title":"Calculating Masses and Distances"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth-a-perfect-real-world-application-of-keplers-third-law-and-newtonian-gravity","text":"","title":"Moon\u2019s orbit around Earth \u2014 a perfect real-world application of Kepler\u2019s Third Law and Newtonian gravity."},{"location":"1%20Physics/2%20Gravity/Problem_1/#known-parameters","text":"Mass of Earth : $$ 5.972 \\times 10^{24} \\, \\text{kg} $$ Average distance from Earth to Moon (r) : $$ 3.844 \\times 10^8 \\, \\text{m} $$ Orbital period of the Moon (T) : $$ 27.3 \\, \\text{days} = 2.36 \\times 10^6 \\, \\text{seconds} $$","title":"Known Parameters:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#using-keplers-third-law","text":"We can verify this with the formula: $$ T^2 = \\frac{4\\pi^2 r^3}{GM} $$ Let\u2019s compute the period from scratch and compare it to the known 27.3 days.","title":"Using Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#result-moons-orbital-period-calculated","text":"Calculated \\( T \\) : 2,371,877 seconds \u2248 27.45 days","title":"Result: Moon\u2019s Orbital Period (Calculated)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-value-273-days","text":"Our calculated value is extremely close to the observed orbital period \u2014 just a slight deviation due to averaging and simplifications (e.g., perfectly circular orbit assumption).","title":"Real value: 27.3 days"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"This shows how Newton\u2019s version of Kepler\u2019s Third Law accurately predicts real-world motion . By just knowing distance and Earth\u2019s mass , we can compute how long it takes the Moon to orbit !","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#exoplanet-discovery","text":"Kepler\u2019s Third Law is used to determine the mass of exoplanets based on their orbits around distant stars.","title":"Exoplanet Discovery"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-simulation-of-circular-orbits","text":"We will now implement a Python simulation to verify the \\( T^2 \\propto r^3 \\) relationship numerically. The simulation will: 1. Define gravitational force and motion equations. 2. Simulate circular orbits using Newton\u2019s Laws. 3. Plot the relationship between \\( T^2 \\) and \\( r^3 \\) . Let's implement this:","title":"4. Computational Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-simulation-and-keplers-law-verification","text":"","title":"Orbital Simulation and Kepler\u2019s Law Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#41-scatter-plot-of-t2-vs-r3-with-best-fit-line","text":"- The linear trendline confirms that \\((T^2)\\) is directly proportional to \\((r^3)\\) . - This supports Kepler\u2019s Third Law: \\((T^2 \\propto r^3)\\) .","title":"4.1 Scatter Plot of \\((T^2)\\) vs. \\((r^3)\\) with Best-Fit Line"},{"location":"1%20Physics/2%20Gravity/Problem_1/#42-log-log-plot-of-t2-vs-r3","text":"- This logarithmic transformation helps visualize power-law relationships. - The straight-line pattern confirms the proportionality.","title":"4.2 Log-Log Plot of \\(T^2\\) vs. \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#43-circular-orbits-of-multiple-planets-at-different-radii","text":"- Each orbit represents a planet at increasing distances from the Sun. - According to Kepler\u2019s Law, planets farther away have longer orbital periods .","title":"4.3 Circular Orbits of Multiple Planets at Different Radii"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-discussion-on-extensions-and-real-world-cases","text":"","title":"5. Discussion on Extensions and Real-World Cases"},{"location":"1%20Physics/2%20Gravity/Problem_1/#elliptical-orbits","text":"For elliptical orbits , Kepler\u2019s Third Law still holds when using the semi-major axis \\( a \\) instead of the orbital radius \\( r \\) . The equation remains: $$ T^2 = \\frac{4\\pi^2}{GM} a^3 $$ where \\( a \\) is the average distance of the object from the central body.","title":"Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-in-space-missions","text":"Used in designing satellite orbits (e.g., GPS satellites, geostationary orbits). Helps determine orbital transfer times , such as Hohmann transfer orbits used in interplanetary travel.","title":"Applications in Space Missions"},{"location":"1%20Physics/2%20Gravity/Problem_1/#generalization-to-binary-systems","text":"In binary star systems, Kepler\u2019s Law is adapted to consider both masses : $$ T^2 = \\frac{4\\pi^2}{G(M_1 + M_2)} a^3 $$ where \\( M_1 \\) and \\( M_2 \\) are the masses of the two orbiting bodies.","title":"Generalization to Binary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-conclusion-and-further-study","text":"Kepler\u2019s Third Law derived, implemented a computational verification, and explored real-world implications. This knowledge is foundational for space exploration, astrophysics, and planetary science! ### Simulation of Hohmann Transfer Orbit","title":"6. Conclusion and Further Study"},{"location":"1%20Physics/2%20Gravity/Problem_1/#whats-happening-in-the-plot","text":"Blue dashed circle : Earth's orbit (1 AU from the Sun). Red dashed circle : Mars' orbit (~1.524 AU). Green arc : The Hohmann transfer path \u2014the most energy-efficient trajectory to reach Mars. Yellow dot : The Sun at the center of the Solar System.","title":"What's Happening in the Plot:"},{"location":"1%20Physics/2%20Gravity/Problem_1/#key-points","text":"The transfer orbit is elliptical , with perihelion at Earth's orbit and aphelion at Mars'. The simulation represents half of the elliptical orbit , which is the typical path a spacecraft takes to go from Earth to Mars.","title":"Key Points:"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Understanding how fast an object needs to go to stay in orbit, escape a planet, or leave the entire Solar System is fundamental in space exploration and mission design. 1. Definitions & Physical Meaning a. First Cosmic Velocity (Orbital Velocity) The minimum speed required to maintain a stable circular orbit close to the planet's surface. \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Used to place satellites into low Earth orbit (LEO). Example: ISS orbits at ~7.66 km/s around Earth. b. Second Cosmic Velocity (Escape Velocity) The minimum speed needed to escape a planet\u2019s gravity without further propulsion. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] Used in missions to the Moon, Mars, etc. Example: Earth escape velocity is ~11.2 km/s. c. Third Cosmic Velocity (Solar Escape Velocity) The speed required to escape the gravitational influence of the Sun starting from a planet's orbit. \\[ v_3 = \\sqrt{\\frac{GM_\\odot}{r_{\\text{orbit}}}} \\] Needed for interstellar probes like Voyager 1. Lower at planets farther from the Sun (e.g., Jupiter). 2. Mathematical Derivations a. First Cosmic Velocity \\(v_1\\) Minimum speed to stay in circular orbit close to surface: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] \\(G\\) : Gravitational constant \\(M\\) : Mass of the planet \\(r\\) : Distance from the planet\u2019s center b. Second Cosmic Velocity \\(v_2\\) Minimum speed to break free from gravity: $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} $$ c. Third Cosmic Velocity \\(v_3\\) Speed to escape Sun\u2019s gravity from Earth's orbit: $$ v_3 = \\sqrt{v_{esc,Sun}^2 + v_{planet-orbit}^2} $$ Where: \\[v_{esc,Sun} = \\sqrt{\\frac{2GM_{Sun}}{r_{orbit}}}\\] \\[v_{planet-orbit} = \\sqrt{\\frac{GM_{Sun}}{r_{orbit}}}\\] 3. Calculations for Earth, Mars, and Jupiter Here are the Cosmic Velocities for Earth , Mars , and Jupiter . Planet 1st Cosmic (Orbital) 2nd Cosmic (Escape) 3rd Cosmic (Solar Escape) Earth ~7.91 km/s ~11.19 km/s ~29.79 km/s Mars ~3.55 km/s ~5.02 km/s ~24.13 km/s Jupiter ~42.57 km/s ~60.20 km/s ~13.05 km/s 4. Graphical Representations of Cosmic Velocities 1st Cosmic Velocity (Orbit) : Needed to stay in low orbit. 2nd Cosmic Velocity (Escape) : Needed to break free from gravity. 3rd Cosmic Velocity (Solar Escape) : Only shown for Earth in this case \u2014 needed to escape the Solar System. 5. Relevance in Space Exploration and Applications Velocity Application 1st Cosmic Required for artificial satellites, space stations. Example: GPS, Starlink, ISS. ( Orbit : The spacecraft keeps circling around the planet.) Velocity Application 2nd Cosmic Required for planetary missions, launching space probes beyond Earth. Example: Moon Missions, Apollo missions, Mars rovers. ( Escape : The path shows a parabolic escape, the spacecraft is going fast enough to break free from Earth\u2019s gravity.) Velocity Application 3rd Cosmic Required for interstellar missions. Example: Voyager 1 & 2 missions. ( Solar System Escape : A fast, hyperbolic escape trajectory; this craft will leave Earth and the entire Solar System.) Significance in Mission Planning : Determines fuel requirements and launch energy . Affects rocket design , payload mass , and mission duration . Vital for interplanetary and interstellar travel .","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"Understanding how fast an object needs to go to stay in orbit, escape a planet, or leave the entire Solar System is fundamental in space exploration and mission design.","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-physical-meaning","text":"","title":"1. Definitions &amp; Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a-first-cosmic-velocity-orbital-velocity","text":"The minimum speed required to maintain a stable circular orbit close to the planet's surface. \\[ v_1 = \\sqrt{\\frac{GM}{R}} \\] Used to place satellites into low Earth orbit (LEO). Example: ISS orbits at ~7.66 km/s around Earth.","title":"a. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#b-second-cosmic-velocity-escape-velocity","text":"The minimum speed needed to escape a planet\u2019s gravity without further propulsion. \\[ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{R}} \\] Used in missions to the Moon, Mars, etc. Example: Earth escape velocity is ~11.2 km/s.","title":"b. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c-third-cosmic-velocity-solar-escape-velocity","text":"The speed required to escape the gravitational influence of the Sun starting from a planet's orbit. \\[ v_3 = \\sqrt{\\frac{GM_\\odot}{r_{\\text{orbit}}}} \\] Needed for interstellar probes like Voyager 1. Lower at planets farther from the Sun (e.g., Jupiter).","title":"c. Third Cosmic Velocity (Solar Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations","text":"","title":"2. Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#a-first-cosmic-velocity-v_1","text":"Minimum speed to stay in circular orbit close to surface: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] \\(G\\) : Gravitational constant \\(M\\) : Mass of the planet \\(r\\) : Distance from the planet\u2019s center","title":"a. First Cosmic Velocity \\(v_1\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#b-second-cosmic-velocity-v_2","text":"Minimum speed to break free from gravity: $$ v_2 = \\sqrt{2} \\cdot v_1 = \\sqrt{\\frac{2GM}{r}} $$","title":"b. Second Cosmic Velocity \\(v_2\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#c-third-cosmic-velocity-v_3","text":"Speed to escape Sun\u2019s gravity from Earth's orbit: $$ v_3 = \\sqrt{v_{esc,Sun}^2 + v_{planet-orbit}^2} $$","title":"c. Third Cosmic Velocity \\(v_3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#where","text":"\\[v_{esc,Sun} = \\sqrt{\\frac{2GM_{Sun}}{r_{orbit}}}\\] \\[v_{planet-orbit} = \\sqrt{\\frac{GM_{Sun}}{r_{orbit}}}\\]","title":"Where:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-calculations-for-earth-mars-and-jupiter","text":"Here are the Cosmic Velocities for Earth , Mars , and Jupiter . Planet 1st Cosmic (Orbital) 2nd Cosmic (Escape) 3rd Cosmic (Solar Escape) Earth ~7.91 km/s ~11.19 km/s ~29.79 km/s Mars ~3.55 km/s ~5.02 km/s ~24.13 km/s Jupiter ~42.57 km/s ~60.20 km/s ~13.05 km/s","title":"3. Calculations for Earth, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-graphical-representations-of-cosmic-velocities","text":"1st Cosmic Velocity (Orbit) : Needed to stay in low orbit. 2nd Cosmic Velocity (Escape) : Needed to break free from gravity. 3rd Cosmic Velocity (Solar Escape) : Only shown for Earth in this case \u2014 needed to escape the Solar System.","title":"4. Graphical Representations of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-relevance-in-space-exploration-and-applications","text":"Velocity Application 1st Cosmic Required for artificial satellites, space stations. Example: GPS, Starlink, ISS. ( Orbit : The spacecraft keeps circling around the planet.) Velocity Application 2nd Cosmic Required for planetary missions, launching space probes beyond Earth. Example: Moon Missions, Apollo missions, Mars rovers. ( Escape : The path shows a parabolic escape, the spacecraft is going fast enough to break free from Earth\u2019s gravity.) Velocity Application 3rd Cosmic Required for interstellar missions. Example: Voyager 1 & 2 missions. ( Solar System Escape : A fast, hyperbolic escape trajectory; this craft will leave Earth and the entire Solar System.)","title":"5. Relevance in Space Exploration and Applications"},{"location":"1%20Physics/2%20Gravity/Problem_2/#significance-in-mission-planning","text":"Determines fuel requirements and launch energy . Affects rocket design , payload mass , and mission duration . Vital for interplanetary and interstellar travel .","title":"Significance in Mission Planning:"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth When a payload is released from a rocket near Earth, its motion is influenced by two key factors: Gravitational attraction from Earth Its initial velocity and direction at the moment of release Depending on these conditions, the payload can follow different paths: Orbital (Elliptical) : bound motion around Earth Parabolic : just enough speed to escape Earth\u2019s gravity Hyperbolic : exceeds escape speed, escaping rapidly Reentry : insufficient speed, falls back to Earth 1. Theoretical Principles The motion of the payload is governed by: Newton\u2019s Law of Universal Gravitation The initial velocity vector of the payload at release These determine whether the object enters orbit, escapes, or returns to Earth. Newton\u2019s Law of Gravitation The gravitational force between two masses is given by: \\[ \\vec{F} = - \\frac{GMm}{r^2} \\, \\hat{r} \\] Where: \\( G \\) : Gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{N\u00b7m}^2/\\text{kg}^2) \\) \\( M \\) : Mass of the Earth \\( ( 5.972 \\times 10^{24} \\, \\text{kg}) \\) \\( m \\) : Mass of the payload \\( r \\) : Distance from Earth's center to the payload \\( \\hat{r} \\) : Unit vector pointing radially outward from Earth to the payload We use Newton's Second Law to derive the equation of motion: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = - \\frac{GM}{r^2} \\hat{r} \\] This gives us a second-order differential equation for motion in 2D space: $$ \\frac{d^2\\vec{r}}{dt^2} = - \\frac{GM}{|\\vec{r}|^3} \\vec{r} $$ Kepler\u2019s Laws Kepler\u2019s Laws describe the motion of planets around the Sun and can be applied to any two-body orbital system: Law of Orbits Planets move in elliptical orbits with the Sun at one focus. Law of Areas A line joining a planet and the Sun sweeps out equal areas in equal intervals of time . Law of Periods The square of a planet\u2019s orbital period is proportional to the cube of the semi-major axis of its orbit. 2. Numerical Simulation of Trajectories We simulate several types of trajectories based on the initial speed and direction of the payload: Elliptical Orbit \\( v < v_{\\text{esc}} \\) (sub-escape speed, tangential to surface) Parabolic Escape \\( v = v_{\\text{esc}} \\) (just enough speed to escape Earth\u2019s gravity) Hyperbolic Trajectory \\( v > v_{\\text{esc}} \\) (excess speed; the object escapes on an open path) Ballistic Reentry \\( v < v_{\\text{orb}} \\) (too slow to maintain orbit, falls back to Earth) Definitions Escape Velocity: $$ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} $$ Orbital Velocity: $$ v_{\\text{orb}} = \\sqrt{\\frac{GM}{r}} $$ 3. Implementation Click to expand full simulation code for velocity, altitude, and angle comparisons import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Time parameters dt = 1 # time step in seconds steps = 30000 # total number of steps (~8 hours) def simulate_trajectory(r0, v0): r = np.array(r0, dtype=float) v = np.array(v0, dtype=float) positions = [r.copy()] for _ in range(steps): r_norm = np.linalg.norm(r) a = -G * M * r / r_norm**3 r += v * dt + 0.5 * a * dt**2 a_new = -G * M * r / np.linalg.norm(r)**3 v += 0.5 * (a + a_new) * dt positions.append(r.copy()) if np.linalg.norm(r) < R_earth: break # hit the Earth return np.array(positions) # Initial position: 300 km above Earth altitude = 300e3 r0 = np.array([R_earth + altitude, 0.0]) # Case 1: Low velocity (reentry) v_reentry = np.array([0.0, 3000.0]) # Case 2: Circular orbital velocity v_orbit = np.array([0.0, np.sqrt(G * M / (R_earth + altitude))]) # Case 3: Escape velocity v_escape = np.array([0.0, np.sqrt(2 * G * M / (R_earth + altitude))]) # Run simulations traj_reentry = simulate_trajectory(r0, v_reentry) traj_orbit = simulate_trajectory(r0, v_orbit) traj_escape = simulate_trajectory(r0, v_escape) # Plotting plt.figure(figsize=(7, 7)) theta = np.linspace(0, 2*np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.plot(earth_x, earth_y, color='black', label='Earth') plt.plot(traj_reentry[:,0], traj_reentry[:,1], label='Reentry', linestyle='--') plt.plot(traj_orbit[:,0], traj_orbit[:,1], label='Orbital', linestyle='-') plt.plot(traj_escape[:,0], traj_escape[:,1], label='Escape', linestyle=':') plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Comparison of Payload Trajectories at Different Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show() Simulation Result: Payload Trajectories Near Earth Here's what you're seeing in the plot: Label Behavior Type of Orbit Suborbital (4 km/s) Falls back to Earth Reentry / crash Orbital (7.7 km/s) Maintains circular/elliptical orbit Bound Orbit Escape (11.2 km/s) Just escapes Earth\u2019s gravity Parabolic Escape Super Escape (13 km/s) Strong escape path, flies away rapidly Hyperbolic Key Physics Insights: Energy = 0 at escape velocity \u21d2 parabolic path Energy < 0 \u21d2 elliptical or suborbital trajectory Energy > 0 \u21d2 hyperbolic trajectory 4. Payload Trajectory Comparisons Python Implementation for Trajectory Simulation and Visualization This implementation is used for all comparisons shown in the plots. The velocity, altitude, and angle parameters are varied to illustrate their effects on orbital behavior. Click to expand full simulation code for velocity, altitude, and angle comparisons import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) dt = 1 # time step (s) steps = 30000 # number of integration steps # Trajectory simulation function def simulate_trajectory(r0, v0): r = np.array(r0, dtype=float) v = np.array(v0, dtype=float) positions = [r.copy()] for _ in range(steps): r_norm = np.linalg.norm(r) a = -G * M * r / r_norm**3 r += v * dt + 0.5 * a * dt**2 a_new = -G * M * r / np.linalg.norm(r)**3 v += 0.5 * (a + a_new) * dt positions.append(r.copy()) if np.linalg.norm(r) < R_earth: break # impact with Earth return np.array(positions) # Earth outline for plotting theta = np.linspace(0, 2 * np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) # -------------------- # Velocity Comparison # -------------------- velocity_cases = { \"3.0 km/s\": 3000, \"4.0 km/s\": 4000, \"6.0 km/s\": 6000, \"7.7 km/s\": 7700, \"9.0 km/s\": 9000, \"11.2 km/s\": 11200, \"13.0 km/s\": 13000 } r0_velocity = np.array([R_earth + 300e3, 0.0]) velocity_trajectories = {} for label, speed in velocity_cases.items(): v0 = [0, speed] velocity_trajectories[label] = simulate_trajectory(r0_velocity, v0) plt.figure(figsize=(8, 8)) plt.plot(earth_x / 1e3, earth_y / 1e3, 'k', label='Earth') for label, traj in velocity_trajectories.items(): plt.plot(traj[:, 0] / 1e3, traj[:, 1] / 1e3, label=label) plt.title(\"Velocity-Based Trajectories\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # -------------------- # Altitude Comparison # -------------------- altitudes_km = [100, 300, 500, 1000] altitude_trajectories = {} speed = 7700 for alt in altitudes_km: r0 = np.array([R_earth + alt * 1e3, 0.0]) v0 = [0, speed] altitude_trajectories[f\"{alt} km\"] = simulate_trajectory(r0, v0) plt.figure(figsize=(8, 8)) plt.plot(earth_x / 1e3, earth_y / 1e3, 'k', label='Earth') for label, traj in altitude_trajectories.items(): plt.plot(traj[:, 0] / 1e3, traj[:, 1] / 1e3, label=label) plt.title(\"Altitude-Based Trajectories\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # -------------------- # Angle Comparison # -------------------- angles_deg = [0, 30, 45, 60, 90, 120] angle_trajectories = {} speed = 7700 r0_angle = np.array([R_earth + 300e3, 0.0]) for angle in angles_deg: angle_rad = np.radians(angle) vx = speed * np.cos(angle_rad) vy = speed * np.sin(angle_rad) v0 = [vx, vy] angle_trajectories[f\"{angle}\u00b0\"] = simulate_trajectory(r0_angle, v0) plt.figure(figsize=(8, 8)) plt.plot(earth_x / 1e3, earth_y / 1e3, 'k', label='Earth') for label, traj in angle_trajectories.items(): plt.plot(traj[:, 0] / 1e3, traj[:, 1] / 1e3, label=label) plt.title(\"Angle-Based Trajectories\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Velocity Comparison Velocity Comparisons Here, we fix the altitude to 300 km and launch angle to 90\u00b0 , and vary the initial speed . Speed (km/s) Resulting Orbit Type 3.0 Immediate reentry 4.0 Suborbital, falls back to Earth 6.0 Partial orbit, returns 7.7 Circular or elliptical orbit 9.0 Elongated elliptical orbit 11.2 Parabolic escape 13.0 Hyperbolic escape This table illustrates how increasing speed increases orbital range and determines escape conditions. Showing how different initial speeds at 300 km altitude (launched vertically) affect the trajectory: Low speeds (3\u20134 km/s): reentry Medium speeds (6\u20139 km/s): elliptical orbits High speeds (11.2+ km/s): escape trajectories Altitude Comparison Here, we fix the speed to 7.7 km/s (near orbital speed) and vary the altitude . Launch angle is kept at 90\u00b0. Altitude (km) Resulting Orbit 100 Smaller elliptical orbit, lower stability 300 Stable low Earth orbit 500 Broader elliptical orbit 1000 Long-period elliptical orbit As altitude increases (100 km \u2192 1000 km), the orbits become wider and more stable. All trajectories start at 90\u00b0 angle with 7.7 km/s speed \u2014 showing how altitude alone influences the orbital shape and duration. Angle Comparison Here, we fix the altitude to 300 km and speed to 7.7 km/s , and vary the launch angle from horizontal (0\u00b0) to vertical (90\u00b0) and beyond. Angle (\u00b0) Resulting Orbit Type 0 Skimming trajectory, reentry likely 30 Low arc, short elliptical path 45 Optimal for range, stable ellipse 60 Higher arc, longer orbit 90 High-altitude ellipse or circular 120 Retrograde-like arc, steep reentry This comparison shows how the launch direction affects orbital characteristics and stability even at the same speed and altitude. All payloads are released from 300 km altitude at 7.7 km/s , but with varying angles. You can see: 0\u00b0 (horizontal) leads to near-surface skimming and reentry. 45\u00b0\u201390\u00b0 create stable orbits. 120\u00b0 launches the payload backward into a steep downward arc.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"When a payload is released from a rocket near Earth, its motion is influenced by two key factors: Gravitational attraction from Earth Its initial velocity and direction at the moment of release Depending on these conditions, the payload can follow different paths: Orbital (Elliptical) : bound motion around Earth Parabolic : just enough speed to escape Earth\u2019s gravity Hyperbolic : exceeds escape speed, escaping rapidly Reentry : insufficient speed, falls back to Earth","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-theoretical-principles","text":"The motion of the payload is governed by: Newton\u2019s Law of Universal Gravitation The initial velocity vector of the payload at release These determine whether the object enters orbit, escapes, or returns to Earth.","title":"1. Theoretical Principles"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The gravitational force between two masses is given by: \\[ \\vec{F} = - \\frac{GMm}{r^2} \\, \\hat{r} \\] Where: \\( G \\) : Gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{N\u00b7m}^2/\\text{kg}^2) \\) \\( M \\) : Mass of the Earth \\( ( 5.972 \\times 10^{24} \\, \\text{kg}) \\) \\( m \\) : Mass of the payload \\( r \\) : Distance from Earth's center to the payload \\( \\hat{r} \\) : Unit vector pointing radially outward from Earth to the payload We use Newton's Second Law to derive the equation of motion: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = - \\frac{GM}{r^2} \\hat{r} \\] This gives us a second-order differential equation for motion in 2D space: $$ \\frac{d^2\\vec{r}}{dt^2} = - \\frac{GM}{|\\vec{r}|^3} \\vec{r} $$","title":"Newton\u2019s Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#keplers-laws","text":"Kepler\u2019s Laws describe the motion of planets around the Sun and can be applied to any two-body orbital system: Law of Orbits Planets move in elliptical orbits with the Sun at one focus. Law of Areas A line joining a planet and the Sun sweeps out equal areas in equal intervals of time . Law of Periods The square of a planet\u2019s orbital period is proportional to the cube of the semi-major axis of its orbit.","title":"Kepler\u2019s Laws"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-simulation-of-trajectories","text":"We simulate several types of trajectories based on the initial speed and direction of the payload: Elliptical Orbit \\( v < v_{\\text{esc}} \\) (sub-escape speed, tangential to surface) Parabolic Escape \\( v = v_{\\text{esc}} \\) (just enough speed to escape Earth\u2019s gravity) Hyperbolic Trajectory \\( v > v_{\\text{esc}} \\) (excess speed; the object escapes on an open path) Ballistic Reentry \\( v < v_{\\text{orb}} \\) (too slow to maintain orbit, falls back to Earth)","title":"2. Numerical Simulation of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#definitions","text":"Escape Velocity: $$ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} $$ Orbital Velocity: $$ v_{\\text{orb}} = \\sqrt{\\frac{GM}{r}} $$","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-implementation","text":"Click to expand full simulation code for velocity, altitude, and angle comparisons import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) # Time parameters dt = 1 # time step in seconds steps = 30000 # total number of steps (~8 hours) def simulate_trajectory(r0, v0): r = np.array(r0, dtype=float) v = np.array(v0, dtype=float) positions = [r.copy()] for _ in range(steps): r_norm = np.linalg.norm(r) a = -G * M * r / r_norm**3 r += v * dt + 0.5 * a * dt**2 a_new = -G * M * r / np.linalg.norm(r)**3 v += 0.5 * (a + a_new) * dt positions.append(r.copy()) if np.linalg.norm(r) < R_earth: break # hit the Earth return np.array(positions) # Initial position: 300 km above Earth altitude = 300e3 r0 = np.array([R_earth + altitude, 0.0]) # Case 1: Low velocity (reentry) v_reentry = np.array([0.0, 3000.0]) # Case 2: Circular orbital velocity v_orbit = np.array([0.0, np.sqrt(G * M / (R_earth + altitude))]) # Case 3: Escape velocity v_escape = np.array([0.0, np.sqrt(2 * G * M / (R_earth + altitude))]) # Run simulations traj_reentry = simulate_trajectory(r0, v_reentry) traj_orbit = simulate_trajectory(r0, v_orbit) traj_escape = simulate_trajectory(r0, v_escape) # Plotting plt.figure(figsize=(7, 7)) theta = np.linspace(0, 2*np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) plt.plot(earth_x, earth_y, color='black', label='Earth') plt.plot(traj_reentry[:,0], traj_reentry[:,1], label='Reentry', linestyle='--') plt.plot(traj_orbit[:,0], traj_orbit[:,1], label='Orbital', linestyle='-') plt.plot(traj_escape[:,0], traj_escape[:,1], label='Escape', linestyle=':') plt.axis('equal') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Comparison of Payload Trajectories at Different Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"3. Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-result-payload-trajectories-near-earth","text":"Here's what you're seeing in the plot: Label Behavior Type of Orbit Suborbital (4 km/s) Falls back to Earth Reentry / crash Orbital (7.7 km/s) Maintains circular/elliptical orbit Bound Orbit Escape (11.2 km/s) Just escapes Earth\u2019s gravity Parabolic Escape Super Escape (13 km/s) Strong escape path, flies away rapidly Hyperbolic","title":"Simulation Result: Payload Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-physics-insights","text":"Energy = 0 at escape velocity \u21d2 parabolic path Energy < 0 \u21d2 elliptical or suborbital trajectory Energy > 0 \u21d2 hyperbolic trajectory","title":"Key Physics Insights:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-payload-trajectory-comparisons","text":"","title":"4. Payload Trajectory Comparisons"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation-for-trajectory-simulation-and-visualization","text":"This implementation is used for all comparisons shown in the plots. The velocity, altitude, and angle parameters are varied to illustrate their effects on orbital behavior. Click to expand full simulation code for velocity, altitude, and angle comparisons import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R_earth = 6.371e6 # radius of Earth (m) dt = 1 # time step (s) steps = 30000 # number of integration steps # Trajectory simulation function def simulate_trajectory(r0, v0): r = np.array(r0, dtype=float) v = np.array(v0, dtype=float) positions = [r.copy()] for _ in range(steps): r_norm = np.linalg.norm(r) a = -G * M * r / r_norm**3 r += v * dt + 0.5 * a * dt**2 a_new = -G * M * r / np.linalg.norm(r)**3 v += 0.5 * (a + a_new) * dt positions.append(r.copy()) if np.linalg.norm(r) < R_earth: break # impact with Earth return np.array(positions) # Earth outline for plotting theta = np.linspace(0, 2 * np.pi, 500) earth_x = R_earth * np.cos(theta) earth_y = R_earth * np.sin(theta) # -------------------- # Velocity Comparison # -------------------- velocity_cases = { \"3.0 km/s\": 3000, \"4.0 km/s\": 4000, \"6.0 km/s\": 6000, \"7.7 km/s\": 7700, \"9.0 km/s\": 9000, \"11.2 km/s\": 11200, \"13.0 km/s\": 13000 } r0_velocity = np.array([R_earth + 300e3, 0.0]) velocity_trajectories = {} for label, speed in velocity_cases.items(): v0 = [0, speed] velocity_trajectories[label] = simulate_trajectory(r0_velocity, v0) plt.figure(figsize=(8, 8)) plt.plot(earth_x / 1e3, earth_y / 1e3, 'k', label='Earth') for label, traj in velocity_trajectories.items(): plt.plot(traj[:, 0] / 1e3, traj[:, 1] / 1e3, label=label) plt.title(\"Velocity-Based Trajectories\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # -------------------- # Altitude Comparison # -------------------- altitudes_km = [100, 300, 500, 1000] altitude_trajectories = {} speed = 7700 for alt in altitudes_km: r0 = np.array([R_earth + alt * 1e3, 0.0]) v0 = [0, speed] altitude_trajectories[f\"{alt} km\"] = simulate_trajectory(r0, v0) plt.figure(figsize=(8, 8)) plt.plot(earth_x / 1e3, earth_y / 1e3, 'k', label='Earth') for label, traj in altitude_trajectories.items(): plt.plot(traj[:, 0] / 1e3, traj[:, 1] / 1e3, label=label) plt.title(\"Altitude-Based Trajectories\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() # -------------------- # Angle Comparison # -------------------- angles_deg = [0, 30, 45, 60, 90, 120] angle_trajectories = {} speed = 7700 r0_angle = np.array([R_earth + 300e3, 0.0]) for angle in angles_deg: angle_rad = np.radians(angle) vx = speed * np.cos(angle_rad) vy = speed * np.sin(angle_rad) v0 = [vx, vy] angle_trajectories[f\"{angle}\u00b0\"] = simulate_trajectory(r0_angle, v0) plt.figure(figsize=(8, 8)) plt.plot(earth_x / 1e3, earth_y / 1e3, 'k', label='Earth') for label, traj in angle_trajectories.items(): plt.plot(traj[:, 0] / 1e3, traj[:, 1] / 1e3, label=label) plt.title(\"Angle-Based Trajectories\") plt.xlabel(\"x (km)\") plt.ylabel(\"y (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Velocity Comparison Velocity Comparisons Here, we fix the altitude to 300 km and launch angle to 90\u00b0 , and vary the initial speed . Speed (km/s) Resulting Orbit Type 3.0 Immediate reentry 4.0 Suborbital, falls back to Earth 6.0 Partial orbit, returns 7.7 Circular or elliptical orbit 9.0 Elongated elliptical orbit 11.2 Parabolic escape 13.0 Hyperbolic escape This table illustrates how increasing speed increases orbital range and determines escape conditions. Showing how different initial speeds at 300 km altitude (launched vertically) affect the trajectory: Low speeds (3\u20134 km/s): reentry Medium speeds (6\u20139 km/s): elliptical orbits High speeds (11.2+ km/s): escape trajectories Altitude Comparison Here, we fix the speed to 7.7 km/s (near orbital speed) and vary the altitude . Launch angle is kept at 90\u00b0. Altitude (km) Resulting Orbit 100 Smaller elliptical orbit, lower stability 300 Stable low Earth orbit 500 Broader elliptical orbit 1000 Long-period elliptical orbit As altitude increases (100 km \u2192 1000 km), the orbits become wider and more stable. All trajectories start at 90\u00b0 angle with 7.7 km/s speed \u2014 showing how altitude alone influences the orbital shape and duration. Angle Comparison Here, we fix the altitude to 300 km and speed to 7.7 km/s , and vary the launch angle from horizontal (0\u00b0) to vertical (90\u00b0) and beyond. Angle (\u00b0) Resulting Orbit Type 0 Skimming trajectory, reentry likely 30 Low arc, short elliptical path 45 Optimal for range, stable ellipse 60 Higher arc, longer orbit 90 High-altitude ellipse or circular 120 Retrograde-like arc, steep reentry This comparison shows how the launch direction affects orbital characteristics and stability even at the same speed and altitude. All payloads are released from 300 km altitude at 7.7 km/s , but with varying angles. You can see: 0\u00b0 (horizontal) leads to near-surface skimming and reentry. 45\u00b0\u201390\u00b0 create stable orbits. 120\u00b0 launches the payload backward into a steep downward arc.","title":"Python Implementation for Trajectory Simulation and Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface from Multiple Point Sources Wave interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easy to observe: ripples from different points meet, producing regions where the waves either reinforce (constructive interference) or cancel each other out (destructive interference). This project models and analyzes interference patterns created by a symmetric arrangement of point sources. Through this simulation, we explore the principles of wave superposition and gain a clearer understanding of how coherent waves interact. Theoretical Model Single-Source Circular Wave A circular wave from a point source located at \\((x_0, y_0)\\) on the water surface is described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: \\( \\eta(x, y, t) \\) = displacement of the water surface at point \\((x, y)\\) and time \\(t\\) \\( A \\) = wave amplitude \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) = distance from source to the point \\( k = \\frac{2\\pi}{\\lambda} \\) = wave number \\( \\omega = 2\\pi f \\) = angular frequency \\( \\phi \\) = initial phase The \\( \\frac{1}{\\sqrt{r}} \\) term models radial amplitude decay (spherical spreading in 2D) Superposition of Multiple Waves For \\(N\\) sources located at the vertices of a regular polygon, the total displacement at a point \\((x, y)\\) is the sum of the individual wave contributions: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(kr_i - \\omega t + \\phi) \\] Where \\( r_i \\) is the distance from the \\(i^{\\text{th}}\\) source to the point \\((x, y)\\) . All sources are assumed to emit coherent waves (same frequency and constant phase relationship). Simulation Setup (Square Configuration) For this simulation: We place 4 point sources at the corners of a square centered at the origin All emit waves with the same amplitude, wavelength, and frequency We compute the net surface displacement at every point on a grid Parameters Used: Amplitude \\( A = 1 \\) Wavelength \\( \\lambda = 2 \\) Frequency \\( f = 1 \\) Polygon: square (4 sources) Static Visualization at \\( t = 0 \\) Interference pattern from square sources Click to expand full simulation code for interference pattern # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude wavelength = 2 # Wavelength (lambda) frequency = 1 # Frequency (f) phi = 0 # Initial phase k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Grid setup grid_size = 300 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) # Square vertex positions (centered) L = 4 # side length vertices = [ (-L/2, -L/2), (-L/2, L/2), ( L/2, L/2), ( L/2, -L/2) ] # Superposition at a fixed time t = 0 t = 0 eta_total = np.zeros_like(X) for (x0, y0) in vertices: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid division by zero eta = (A / np.sqrt(R)) * np.cos(k * R - omega * t + phi) eta_total += eta # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='RdBu') plt.colorbar(label='Displacement \u03b7(x, y, t=0)') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show() Fig. : The water surface displacement due to four coherent wave sources arranged in a square. Bright areas show constructive interference; dark regions show destructive interference. Animated Visualization Wave animation (varying t only) Click to expand full simulation code for animated GIF showing the interference pattern of four wave import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # --- Parameters --- A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency phi = 0 # Initial phase k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # --- Grid setup --- grid_size = 300 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) # --- Square vertices (sources) --- L = 4 # Side length of square vertices = [ (-L/2, -L/2), (-L/2, L/2), ( L/2, L/2), ( L/2, -L/2) ] # --- Set up the figure --- fig, ax = plt.subplots(figsize=(8, 6)) cmap = plt.get_cmap('RdBu') # Initial contour (dummy) contour = ax.contourf(X, Y, np.zeros_like(X), levels=100, cmap=cmap) cbar = plt.colorbar(contour, ax=ax) cbar.set_label('Displacement \u03b7(x, y, t)') ax.set_title('Wave Interference Pattern') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') # --- Update function for animation --- def update(frame): t = frame * 0.1 # Time increment eta_total = np.zeros_like(X) for (x0, y0) in vertices: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Small term to avoid divide-by-zero eta = (A / np.sqrt(R)) * np.cos(k * R - omega * t + phi) eta_total += eta ax.clear() contour = ax.contourf(X, Y, eta_total, levels=100, cmap=cmap) ax.set_title(f'Wave Interference at t = {t:.1f} s') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') return contour.collections # --- Create animation --- ani = animation.FuncAnimation(fig, update, frames=60, blit=False) # --- Save as GIF --- ani.save('square_wave_interference.gif', writer='pillow', fps=10) plt.close(fig) Wave animation (varying t only) Fig. : Animated view of wave interference over time. Standing wave-like zones emerge where waves reinforce or cancel consistently. Interference Pattern Analysis Symmetry The square symmetry leads to rotational and reflectional symmetry in the interference pattern. Patterns radiate outward but maintain consistent nodal (zero-displacement) and antinodal (maximum displacement) structures. Constructive Interference Occurs where the path difference from multiple sources is an integer multiple of the wavelength: \\[ \\Delta r = n\\lambda \\quad (n \\in \\mathbb{Z}) \\] At these points, waves arrive in-phase and amplify. Destructive Interference Occurs when the path difference equals a half-integer multiple of the wavelength: \\[ \\Delta r = \\left(n + \\frac{1}{2}\\right)\\lambda \\] Waves arrive out-of-phase and cancel out. Effect of Parameters (Discussion) Parameter Effect on Pattern Wavelength Longer wavelength \u2192 broader fringes Frequency Affects animation speed (not spatial shape) Amplitude Affects brightness/intensity only Polygon Shape More sides \u2192 circular symmetry emerges Conclusion This simulation offers a clear visual demonstration of wave interference principles: Constructive and destructive interference arise naturally from the superposition of waves. The geometry of the source arrangement shapes the spatial structure of the resulting pattern. These concepts apply broadly to light, sound, and quantum waves, highlighting the fundamental role of interference across all areas of wave physics.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface-from-multiple-point-sources","text":"Wave interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this is easy to observe: ripples from different points meet, producing regions where the waves either reinforce (constructive interference) or cancel each other out (destructive interference). This project models and analyzes interference patterns created by a symmetric arrangement of point sources. Through this simulation, we explore the principles of wave superposition and gain a clearer understanding of how coherent waves interact.","title":"Interference Patterns on a Water Surface from Multiple Point Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-model","text":"","title":"Theoretical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-source-circular-wave","text":"A circular wave from a point source located at \\((x_0, y_0)\\) on the water surface is described by: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(kr - \\omega t + \\phi) \\] Where: \\( \\eta(x, y, t) \\) = displacement of the water surface at point \\((x, y)\\) and time \\(t\\) \\( A \\) = wave amplitude \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) = distance from source to the point \\( k = \\frac{2\\pi}{\\lambda} \\) = wave number \\( \\omega = 2\\pi f \\) = angular frequency \\( \\phi \\) = initial phase The \\( \\frac{1}{\\sqrt{r}} \\) term models radial amplitude decay (spherical spreading in 2D)","title":"Single-Source Circular Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-multiple-waves","text":"For \\(N\\) sources located at the vertices of a regular polygon, the total displacement at a point \\((x, y)\\) is the sum of the individual wave contributions: \\[ \\eta_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{\\sqrt{r_i}} \\cos(kr_i - \\omega t + \\phi) \\] Where \\( r_i \\) is the distance from the \\(i^{\\text{th}}\\) source to the point \\((x, y)\\) . All sources are assumed to emit coherent waves (same frequency and constant phase relationship).","title":"Superposition of Multiple Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-setup-square-configuration","text":"For this simulation: We place 4 point sources at the corners of a square centered at the origin All emit waves with the same amplitude, wavelength, and frequency We compute the net surface displacement at every point on a grid","title":"Simulation Setup (Square Configuration)"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters-used","text":"Amplitude \\( A = 1 \\) Wavelength \\( \\lambda = 2 \\) Frequency \\( f = 1 \\) Polygon: square (4 sources)","title":"Parameters Used:"},{"location":"1%20Physics/3%20Waves/Problem_1/#static-visualization-at-t-0","text":"Interference pattern from square sources Click to expand full simulation code for interference pattern # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 # Amplitude wavelength = 2 # Wavelength (lambda) frequency = 1 # Frequency (f) phi = 0 # Initial phase k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # Grid setup grid_size = 300 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) # Square vertex positions (centered) L = 4 # side length vertices = [ (-L/2, -L/2), (-L/2, L/2), ( L/2, L/2), ( L/2, -L/2) ] # Superposition at a fixed time t = 0 t = 0 eta_total = np.zeros_like(X) for (x0, y0) in vertices: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Avoid division by zero eta = (A / np.sqrt(R)) * np.cos(k * R - omega * t + phi) eta_total += eta # Plotting plt.figure(figsize=(8, 6)) plt.contourf(X, Y, eta_total, levels=100, cmap='RdBu') plt.colorbar(label='Displacement \u03b7(x, y, t=0)') plt.title('Interference Pattern from 4 Point Sources (Square)') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.tight_layout() plt.show() Fig. : The water surface displacement due to four coherent wave sources arranged in a square. Bright areas show constructive interference; dark regions show destructive interference.","title":"Static Visualization at \\( t = 0 \\)"},{"location":"1%20Physics/3%20Waves/Problem_1/#animated-visualization","text":"Wave animation (varying t only) Click to expand full simulation code for animated GIF showing the interference pattern of four wave import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation # --- Parameters --- A = 1 # Amplitude wavelength = 2 # Wavelength frequency = 1 # Frequency phi = 0 # Initial phase k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency # --- Grid setup --- grid_size = 300 x = np.linspace(-5, 5, grid_size) y = np.linspace(-5, 5, grid_size) X, Y = np.meshgrid(x, y) # --- Square vertices (sources) --- L = 4 # Side length of square vertices = [ (-L/2, -L/2), (-L/2, L/2), ( L/2, L/2), ( L/2, -L/2) ] # --- Set up the figure --- fig, ax = plt.subplots(figsize=(8, 6)) cmap = plt.get_cmap('RdBu') # Initial contour (dummy) contour = ax.contourf(X, Y, np.zeros_like(X), levels=100, cmap=cmap) cbar = plt.colorbar(contour, ax=ax) cbar.set_label('Displacement \u03b7(x, y, t)') ax.set_title('Wave Interference Pattern') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') # --- Update function for animation --- def update(frame): t = frame * 0.1 # Time increment eta_total = np.zeros_like(X) for (x0, y0) in vertices: R = np.sqrt((X - x0)**2 + (Y - y0)**2) + 1e-6 # Small term to avoid divide-by-zero eta = (A / np.sqrt(R)) * np.cos(k * R - omega * t + phi) eta_total += eta ax.clear() contour = ax.contourf(X, Y, eta_total, levels=100, cmap=cmap) ax.set_title(f'Wave Interference at t = {t:.1f} s') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_aspect('equal') return contour.collections # --- Create animation --- ani = animation.FuncAnimation(fig, update, frames=60, blit=False) # --- Save as GIF --- ani.save('square_wave_interference.gif', writer='pillow', fps=10) plt.close(fig) Wave animation (varying t only) Fig. : Animated view of wave interference over time. Standing wave-like zones emerge where waves reinforce or cancel consistently.","title":"Animated Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-pattern-analysis","text":"","title":"Interference Pattern Analysis"},{"location":"1%20Physics/3%20Waves/Problem_1/#symmetry","text":"The square symmetry leads to rotational and reflectional symmetry in the interference pattern. Patterns radiate outward but maintain consistent nodal (zero-displacement) and antinodal (maximum displacement) structures.","title":"Symmetry"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-interference","text":"Occurs where the path difference from multiple sources is an integer multiple of the wavelength: \\[ \\Delta r = n\\lambda \\quad (n \\in \\mathbb{Z}) \\] At these points, waves arrive in-phase and amplify.","title":"Constructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#destructive-interference","text":"Occurs when the path difference equals a half-integer multiple of the wavelength: \\[ \\Delta r = \\left(n + \\frac{1}{2}\\right)\\lambda \\] Waves arrive out-of-phase and cancel out.","title":"Destructive Interference"},{"location":"1%20Physics/3%20Waves/Problem_1/#effect-of-parameters-discussion","text":"Parameter Effect on Pattern Wavelength Longer wavelength \u2192 broader fringes Frequency Affects animation speed (not spatial shape) Amplitude Affects brightness/intensity only Polygon Shape More sides \u2192 circular symmetry emerges","title":"Effect of Parameters (Discussion)"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation offers a clear visual demonstration of wave interference principles: Constructive and destructive interference arise naturally from the superposition of waves. The geometry of the source arrangement shapes the spatial structure of the resulting pattern. These concepts apply broadly to light, sound, and quantum waves, highlighting the fundamental role of interference across all areas of wave physics.","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force describes how electric and magnetic fields affect charged particles. It plays a key role in technologies like mass spectrometers , cyclotrons , and fusion devices . The Lorentz force is given by: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: - \\( \\vec{F} \\) is the total force acting on the particle, - \\( q \\) is the particle's electric charge, - \\( \\vec{E} \\) is the electric field, - \\( \\vec{B} \\) is the magnetic field, - \\( \\vec{v} \\) is the velocity of the particle. Applications of the Lorentz Force System Role of the Lorentz Force Cyclotrons / Synchrotrons Circular motion induced by magnetic fields accelerates particles. Mass Spectrometers Different ions curve based on \\( q/m \\) , enabling identification. Plasma Confinement Magnetic fields trap charged particles in fusion devices. Auroras & Solar Wind Charged particles spiral along Earth's magnetic field lines. The ability to control charged particles using \\( \\vec{E} \\) and \\( \\vec{B} \\) fields is foundational in both scientific instrumentation and industrial technology. Theoretical Derivation Uniform Magnetic Field \\( \\vec{B} = B\\hat{z} \\) , No Electric Field For a charged particle moving in the \\( xy \\) -plane with velocity \\( \\vec{v} = v_x\\hat{x} + v_y\\hat{y} \\) , the magnetic part of the Lorentz force is: \\[ \\vec{F} = q(\\vec{v} \\times \\vec{B}) = q \\begin{vmatrix} \\hat{x} & \\hat{y} & \\hat{z} \\\\ v_x & v_y & 0 \\\\ 0 & 0 & B \\end{vmatrix} = qB(v_y\\hat{x} - v_x\\hat{y}) \\] This leads to coupled differential equations: \\[ m\\frac{dv_x}{dt} = qBv_y \\\\ m\\frac{dv_y}{dt} = -qBv_x \\] Taking a time derivative of the first and substituting: \\[ \\frac{d^2v_x}{dt^2} = -\\left( \\frac{qB}{m} \\right)^2 v_x \\] Which is the equation of simple harmonic motion , meaning the particle undergoes circular motion at the cyclotron frequency : \\[ \\omega_c = \\frac{qB}{m} \\] The radius of the motion is the Larmor radius : \\[ r_L = \\frac{mv_\\perp}{|q|B} \\] Where \\( v_\\perp \\) is the velocity component perpendicular to the field. Lorentz Force in a Uniform Magnetic Field Let\u2019s consider a charged particle moving in a uniform magnetic field \\( \\vec{B} = B\\hat{z} \\) , with no electric field. The Lorentz force becomes: \\[ \\vec{F} = q(\\vec{v} \\times \\vec{B}) \\] If the particle\u2019s velocity is in the \\( xy \\) -plane: \\[ \\vec{v} = v_x \\hat{x} + v_y \\hat{y} \\] Then: \\[ \\vec{F} = qB(v_y \\hat{x} - v_x \\hat{y}) \\] This leads to two coupled equations: \\[ m\\frac{dv_x}{dt} = qBv_y \\\\ m\\frac{dv_y}{dt} = -qBv_x \\] These describe circular motion at the cyclotron frequency : \\[ \\omega_c = \\frac{qB}{m} \\] And the radius of the circular path is the Larmor radius : \\[ r_L = \\frac{mv_\\perp}{|q|B} \\] Where \\( v_\\perp \\) is the component of velocity perpendicular to the magnetic field. In this configuration, the particle traces a circle (or a helix if it has a velocity component along \\( \\vec{B} \\) ). Simulation 1: Motion in a Uniform Magnetic Field Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) B = 1.0 # Magnetic field strength (T) v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1000 # Initialize arrays positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Magnetic field vector (along z-axis) B_vec = np.array([0, 0, B]) # Euler method integration for i in range(steps - 1): v = velocities[i] F = q * np.cross(v, B_vec) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt # Plotting trajectory in xy-plane plt.figure(figsize=(6, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Particle Path') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Uniform Magnetic Field') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Fig. : A charged particle moves in a circular path in the \\(xy\\) -plane under a uniform magnetic field along the \\(z\\) -axis. The Lorentz force acts perpendicular to velocity, producing uniform circular motion. Simulation 2: Motion in Combined Electric and Magnetic Fields Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.5, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v0 = np.array([1.0, 0.0, 1.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1500 # Initialize arrays positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Euler method integration with E and B for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt # 3D Plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2], label='Particle Path') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Charged Particle in Combined E and B Fields') ax.legend() plt.tight_layout() plt.show() Fig. : The particle follows a spiral trajectory due to the magnetic field while being steadily accelerated in the direction of the electric field. This results in a helical path that drifts along the \ud835\udc65 x-axis. Simulation 3 \u2013 Crossed Electric and Magnetic Fields (E \u00d7 B Drift) Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v0 = np.array([0.0, 0.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1500 # Initialize arrays positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Euler method for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt # Plot in xy-plane plt.figure(figsize=(7, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Particle Path') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Crossed E and B Fields (E \u00d7 B Drift)') plt.grid(True) plt.axis('equal') plt.legend() plt.tight_layout() plt.show() Fig. : In crossed electric and magnetic fields, the particle follows a curved path but drifts steadily perpendicular to both fields. This E \u00d7 B drift occurs at a constant velocity \\(\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) . Parameter Sweep 1: Varying Magnetic Field Strength \ud835\udc35 Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 m = 1.0 E = np.array([1.0, 0.0, 0.0]) B_values = [0.5, 1.0, 2.0] v0 = np.array([0.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 steps = 1500 fig, ax = plt.subplots(figsize=(7, 6)) for B_mag in B_values: positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 B = np.array([0, 0, B_mag]) for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt ax.plot(positions[:, 0], positions[:, 1], label=f'B = {B_mag} T') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Effect of Magnetic Field Strength on E \u00d7 B Drift') ax.grid(True) ax.axis('equal') ax.legend() plt.tight_layout() plt.savefig(\"exb_drift_B_variation.png\") Fig. : Particle paths under different magnetic field strengths. Stronger B results in tighter curvature and faster E \u00d7 B drift alignment. Weaker fields produce broader arcs and slower net motion. Parameter Sweep 2: Varying Electric Field Strength E Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 m = 1.0 B = np.array([0.0, 0.0, 1.0]) E_values = [0.5, 1.0, 2.0] v0 = np.array([0.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 steps = 1500 fig, ax = plt.subplots(figsize=(7, 6)) for E_mag in E_values: E = np.array([E_mag, 0.0, 0.0]) positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt ax.plot(positions[:, 0], positions[:, 1], label=f'E = {E_mag} V/m') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Effect of Electric Field Strength on E \u00d7 B Drift') ax.grid(True) ax.axis('equal') ax.legend() plt.tight_layout() plt.savefig(\"exb_drift_E_variation.png\") Fig. : Particle trajectories for different electric field strengths. Higher \ud835\udc38 leads to faster E \u00d7 B drift and wider loop spacing, while \ud835\udc35 remains fixed. Parameter Sweep 3: Initial Velocity Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 m = 1.0 E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0_values = [np.array([0.0, 0.0, 0.0]), np.array([0.5, 0.5, 0.0]), np.array([1.0, 0.0, 1.0])] r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 steps = 1500 fig, ax = plt.subplots(figsize=(7, 6)) for v0 in v0_values: positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 for j in range(steps - 1): v = velocities[j] F = q * (E + np.cross(v, B)) a = F / m velocities[j + 1] = v + a * dt positions[j + 1] = positions[j] + velocities[j + 1] * dt label = f'v\u2080 = [{v0[0]}, {v0[1]}, {v0[2]}] m/s' ax.plot(positions[:, 0], positions[:, 1], label=label) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Effect of Initial Velocity on E \u00d7 B Drift') ax.grid(True) ax.axis('equal') ax.legend() plt.tight_layout() plt.savefig(\"exb_drift_v0_variation.png\") Fig. : Changing the initial velocity affects the particle's curvature and orientation but not the net drift direction, which remains governed by \\(\\vec{E} \\times \\vec{B}\\) . Conclusion This study demonstrated how charged particles move under electric and magnetic fields, following predictable paths like circles, helices, or drifts. By changing field strengths and initial velocity, we saw how these factors shape the motion. The results confirm the Lorentz force as a key principle in understanding and controlling particle behavior in practical systems.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force describes how electric and magnetic fields affect charged particles. It plays a key role in technologies like mass spectrometers , cyclotrons , and fusion devices . The Lorentz force is given by: \\[ \\vec{F} = q\\vec{E} + q\\vec{v} \\times \\vec{B} \\] Where: - \\( \\vec{F} \\) is the total force acting on the particle, - \\( q \\) is the particle's electric charge, - \\( \\vec{E} \\) is the electric field, - \\( \\vec{B} \\) is the magnetic field, - \\( \\vec{v} \\) is the velocity of the particle.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"System Role of the Lorentz Force Cyclotrons / Synchrotrons Circular motion induced by magnetic fields accelerates particles. Mass Spectrometers Different ions curve based on \\( q/m \\) , enabling identification. Plasma Confinement Magnetic fields trap charged particles in fusion devices. Auroras & Solar Wind Charged particles spiral along Earth's magnetic field lines. The ability to control charged particles using \\( \\vec{E} \\) and \\( \\vec{B} \\) fields is foundational in both scientific instrumentation and industrial technology.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theoretical-derivation","text":"","title":"Theoretical Derivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#uniform-magnetic-field-vecb-bhatz-no-electric-field","text":"For a charged particle moving in the \\( xy \\) -plane with velocity \\( \\vec{v} = v_x\\hat{x} + v_y\\hat{y} \\) , the magnetic part of the Lorentz force is: \\[ \\vec{F} = q(\\vec{v} \\times \\vec{B}) = q \\begin{vmatrix} \\hat{x} & \\hat{y} & \\hat{z} \\\\ v_x & v_y & 0 \\\\ 0 & 0 & B \\end{vmatrix} = qB(v_y\\hat{x} - v_x\\hat{y}) \\] This leads to coupled differential equations: \\[ m\\frac{dv_x}{dt} = qBv_y \\\\ m\\frac{dv_y}{dt} = -qBv_x \\] Taking a time derivative of the first and substituting: \\[ \\frac{d^2v_x}{dt^2} = -\\left( \\frac{qB}{m} \\right)^2 v_x \\] Which is the equation of simple harmonic motion , meaning the particle undergoes circular motion at the cyclotron frequency : \\[ \\omega_c = \\frac{qB}{m} \\] The radius of the motion is the Larmor radius : \\[ r_L = \\frac{mv_\\perp}{|q|B} \\] Where \\( v_\\perp \\) is the velocity component perpendicular to the field.","title":"Uniform Magnetic Field \\( \\vec{B} = B\\hat{z} \\), No Electric Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-in-a-uniform-magnetic-field","text":"Let\u2019s consider a charged particle moving in a uniform magnetic field \\( \\vec{B} = B\\hat{z} \\) , with no electric field. The Lorentz force becomes: \\[ \\vec{F} = q(\\vec{v} \\times \\vec{B}) \\] If the particle\u2019s velocity is in the \\( xy \\) -plane: \\[ \\vec{v} = v_x \\hat{x} + v_y \\hat{y} \\] Then: \\[ \\vec{F} = qB(v_y \\hat{x} - v_x \\hat{y}) \\] This leads to two coupled equations: \\[ m\\frac{dv_x}{dt} = qBv_y \\\\ m\\frac{dv_y}{dt} = -qBv_x \\] These describe circular motion at the cyclotron frequency : \\[ \\omega_c = \\frac{qB}{m} \\] And the radius of the circular path is the Larmor radius : \\[ r_L = \\frac{mv_\\perp}{|q|B} \\] Where \\( v_\\perp \\) is the component of velocity perpendicular to the magnetic field. In this configuration, the particle traces a circle (or a helix if it has a velocity component along \\( \\vec{B} \\) ).","title":"Lorentz Force in a Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-1-motion-in-a-uniform-magnetic-field","text":"Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) B = 1.0 # Magnetic field strength (T) v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1000 # Initialize arrays positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Magnetic field vector (along z-axis) B_vec = np.array([0, 0, B]) # Euler method integration for i in range(steps - 1): v = velocities[i] F = q * np.cross(v, B_vec) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt # Plotting trajectory in xy-plane plt.figure(figsize=(6, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Particle Path') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Uniform Magnetic Field') plt.axis('equal') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Fig. : A charged particle moves in a circular path in the \\(xy\\) -plane under a uniform magnetic field along the \\(z\\) -axis. The Lorentz force acts perpendicular to velocity, producing uniform circular motion.","title":"Simulation 1: Motion in a Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-2-motion-in-combined-electric-and-magnetic-fields","text":"Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.5, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v0 = np.array([1.0, 0.0, 1.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1500 # Initialize arrays positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Euler method integration with E and B for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt # 3D Plot fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot3D(positions[:, 0], positions[:, 1], positions[:, 2], label='Particle Path') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_zlabel('z (m)') ax.set_title('Charged Particle in Combined E and B Fields') ax.legend() plt.tight_layout() plt.show() Fig. : The particle follows a spiral trajectory due to the magnetic field while being steadily accelerated in the direction of the electric field. This results in a helical path that drifts along the \ud835\udc65 x-axis.","title":"Simulation 2: Motion in Combined Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-3-crossed-electric-and-magnetic-fields-e-b-drift","text":"Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Parameters q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) v0 = np.array([0.0, 0.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) # Time settings dt = 0.01 steps = 1500 # Initialize arrays positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 # Euler method for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt # Plot in xy-plane plt.figure(figsize=(7, 6)) plt.plot(positions[:, 0], positions[:, 1], label='Particle Path') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Crossed E and B Fields (E \u00d7 B Drift)') plt.grid(True) plt.axis('equal') plt.legend() plt.tight_layout() plt.show() Fig. : In crossed electric and magnetic fields, the particle follows a curved path but drifts steadily perpendicular to both fields. This E \u00d7 B drift occurs at a constant velocity \\(\\vec{v}_{\\text{drift}} = \\frac{\\vec{E} \\times \\vec{B}}{B^2}\\) .","title":"Simulation 3 \u2013 Crossed Electric and Magnetic Fields (E \u00d7 B Drift)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-sweep-1-varying-magnetic-field-strength-b","text":"Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 m = 1.0 E = np.array([1.0, 0.0, 0.0]) B_values = [0.5, 1.0, 2.0] v0 = np.array([0.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 steps = 1500 fig, ax = plt.subplots(figsize=(7, 6)) for B_mag in B_values: positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 B = np.array([0, 0, B_mag]) for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt ax.plot(positions[:, 0], positions[:, 1], label=f'B = {B_mag} T') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Effect of Magnetic Field Strength on E \u00d7 B Drift') ax.grid(True) ax.axis('equal') ax.legend() plt.tight_layout() plt.savefig(\"exb_drift_B_variation.png\") Fig. : Particle paths under different magnetic field strengths. Stronger B results in tighter curvature and faster E \u00d7 B drift alignment. Weaker fields produce broader arcs and slower net motion.","title":"Parameter Sweep 1: Varying Magnetic Field Strength \ud835\udc35"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-sweep-2-varying-electric-field-strength-e","text":"Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 m = 1.0 B = np.array([0.0, 0.0, 1.0]) E_values = [0.5, 1.0, 2.0] v0 = np.array([0.0, 0.0, 0.0]) r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 steps = 1500 fig, ax = plt.subplots(figsize=(7, 6)) for E_mag in E_values: E = np.array([E_mag, 0.0, 0.0]) positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 for i in range(steps - 1): v = velocities[i] F = q * (E + np.cross(v, B)) a = F / m velocities[i + 1] = v + a * dt positions[i + 1] = positions[i] + velocities[i + 1] * dt ax.plot(positions[:, 0], positions[:, 1], label=f'E = {E_mag} V/m') ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Effect of Electric Field Strength on E \u00d7 B Drift') ax.grid(True) ax.axis('equal') ax.legend() plt.tight_layout() plt.savefig(\"exb_drift_E_variation.png\") Fig. : Particle trajectories for different electric field strengths. Higher \ud835\udc38 leads to faster E \u00d7 B drift and wider loop spacing, while \ud835\udc35 remains fixed.","title":"Parameter Sweep 2: Varying Electric Field Strength E"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-sweep-3-initial-velocity","text":"Click to expand full simulation code # Re-run after kernel reset import numpy as np import matplotlib.pyplot as plt # Constants q = 1.0 m = 1.0 E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0_values = [np.array([0.0, 0.0, 0.0]), np.array([0.5, 0.5, 0.0]), np.array([1.0, 0.0, 1.0])] r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 steps = 1500 fig, ax = plt.subplots(figsize=(7, 6)) for v0 in v0_values: positions = np.zeros((steps, 3)) velocities = np.zeros((steps, 3)) positions[0] = r0 velocities[0] = v0 for j in range(steps - 1): v = velocities[j] F = q * (E + np.cross(v, B)) a = F / m velocities[j + 1] = v + a * dt positions[j + 1] = positions[j] + velocities[j + 1] * dt label = f'v\u2080 = [{v0[0]}, {v0[1]}, {v0[2]}] m/s' ax.plot(positions[:, 0], positions[:, 1], label=label) ax.set_xlabel('x (m)') ax.set_ylabel('y (m)') ax.set_title('Effect of Initial Velocity on E \u00d7 B Drift') ax.grid(True) ax.axis('equal') ax.legend() plt.tight_layout() plt.savefig(\"exb_drift_v0_variation.png\") Fig. : Changing the initial velocity affects the particle's curvature and orientation but not the net drift direction, which remains governed by \\(\\vec{E} \\times \\vec{B}\\) .","title":"Parameter Sweep 3: Initial Velocity"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This study demonstrated how charged particles move under electric and magnetic fields, following predictable paths like circles, helices, or drifts. By changing field strengths and initial velocity, we saw how these factors shape the motion. The results confirm the Lorentz force as a key principle in understanding and controlling particle behavior in practical systems.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating the equivalent resistance of a circuit is essential for understanding current flow and energy use. Traditional methods become complex with large circuits, especially when combinations of series and parallel resistors are nested. Implementation Strategy We represent the circuit as a weighted graph using a MultiGraph structure, where: Each node is a junction in the circuit. Each edge is a resistor, with its resistance stored as an edge weight. The simplification algorithm works by: Identifying parallel resistors \u2014 multiple edges between the same two nodes \u2014 and replacing them with one equivalent edge using: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum \\frac{1}{R_i} \\] Identifying series resistors \u2014 paths through intermediate nodes of degree 2 \u2014 and collapsing them into a single resistor using: $$ R_{\\text{eq}} = R_1 + R_2 + \\dots $$ This process repeats iteratively until the graph reduces to a single equivalent resistor between the input and output terminals. Python Implementation We implement the algorithm using the networkx library. The graph is simplified by: Merging parallel edges into one equivalent resistor. Collapsing series paths through non-terminal nodes. The algorithm continues until no further reductions can be made. Click to Expand Python Implementation ```python import networkx as nx def simplify_circuit(G, start, end): G = G.copy() while True: changed = False # Merge parallel resistors for u, v in list(G.edges()): keys = list(G[u][v].keys()) if len(keys) > 1: resistances = [G[u][v][k]['resistance'] for k in keys] R_parallel = 1 / sum(1 / R for R in resistances) G.remove_edges_from([(u, v, k) for k in keys]) G.add_edge(u, v, resistance=R_parallel) changed = True break # restart after modification if changed: continue # Collapse series nodes for node in list(G.nodes()): if node in (start, end) or G.degree(node) != 2: continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: edge1 = list(G.get_edge_data(node, neighbors[0]).values())[0] edge2 = list(G.get_edge_data(node, neighbors[1]).values())[0] R_series = edge1['resistance'] + edge2['resistance'] G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], resistance=R_series) changed = True break if not changed: break # Return result if G.has_edge(start, end): return list(G.get_edge_data(start, end).values())[0]['resistance'] else: return float('inf') # no path Example 1: Mixed Series and Parallel Resistors Click to Expand Visual's Code ```python # Define graph structure G1 = nx.MultiGraph() G1.add_edge('A', 'B', resistance=4) G1.add_edge('B', 'C', resistance=6) G1.add_edge('A', 'C', resistance=12) # Visualization function def draw_multigraph_as_simple(G_multi, title, filename): G_simple = nx.Graph() for u, v, data in G_multi.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels) plt.title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Draw graph draw_multigraph_as_simple(G1, \"Example 1: Mixed Series and Parallel\", \"example1_graph_fixed\") Circuit: A\u2013B\u2013C is a series path: - A\u2013B = 4 \u03a9 - B\u2013C = 6 \u03a9 A direct A\u2013C path also exists: - A\u2013C = 12 \u03a9 Interpretation: The 4 \u03a9 and 6 \u03a9 are in series \u2192 10 \u03a9 This 10 \u03a9 is in parallel with 12 \u03a9 Expected Result: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{12} \\Rightarrow R_{\\text{eq}} \\approx 5.45\\ \\Omega \\] Example 1: Step-by-Step Simplification: Fig. : Left: After collapsing the A\u2013B\u2013C series path into a single 10 \u03a9 edge, the circuit includes two parallel resistors between A and C. Fig. : Right: These are then reduced to one equivalent resistor of 5.45 \u03a9, completing the simplification. Click to Expand Example 1: Step-by-Step Simplification Code ```python # Define both graphs G_step1 = nx.MultiGraph() G_step1.add_edge('A', 'C', resistance=10) G_step1.add_edge('A', 'C', resistance=12) G_final = nx.MultiGraph() G_final.add_edge('A', 'C', resistance=5.45) # Visualization function def draw_combined_steps(G1, G2, titles, filename): fig, axes = plt.subplots(1, 2, figsize=(12, 5)) for ax, G, title in zip(axes, [G1, G2], titles): G_simple = nx.Graph() for u, v, data in G.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold', ax=ax) nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels, ax=ax) ax.set_title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Create and save combined figure draw_combined_steps(G_step1, G_final, [\"Step 1: Series Collapsed\", \"Step 2: Final Equivalent\"], \"example1_combined_steps\") Example 2: Nested Series and Parallel Configuration Click to Expand Visual's Code ```python # Define graph structure G2 = nx.MultiGraph() G2.add_edge('A', 'B', resistance=3) G2.add_edge('B', 'C', resistance=6) G2.add_edge('B', 'D', resistance=6) G2.add_edge('C', 'D', resistance=6) G2.add_edge('D', 'E', resistance=3) # Visualization function def draw_multigraph_as_simple(G_multi, title, filename): G_simple = nx.Graph() for u, v, data in G_multi.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels) plt.title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Draw graph draw_multigraph_as_simple(G2, \"Example 2: Nested Series and Parallel\", \"example2_graph\") Circuit: A\u2013B = 3 \u03a9 B\u2013C = 6 \u03a9 B\u2013D = 6 \u03a9 C\u2013D = 6 \u03a9 D\u2013E = 3 \u03a9 Interpretation: Nodes C and D form a parallel pair (6 \u03a9 || 6 \u03a9 = 3 \u03a9) B\u2013(C,D)\u2013E becomes a series chain : 6 + 3 + 3 = 12 \u03a9 Final path A\u2013B\u2013(C,D)\u2013D\u2013E = 3 + 12 = 15 \u03a9 Example 2 \u2013 Step-by-Step Simplification: Fig. : Left: The triangular B\u2013C\u2013D configuration is reduced to a single 4 \u03a9 equivalent resistor between B and D. Fig. : Right: The resulting A\u2013B\u2013D\u2013E path (3 + 4 + 3) is simplified into one 10 \u03a9 resistor between A and E. Click to Expand Example 2: Step-by-Step Simplification Code ```python # Step 1: Triangle B\u2013C\u2013D reduced G2_step1_corrected = nx.MultiGraph() G2_step1_corrected.add_edge('A', 'B', resistance=3) G2_step1_corrected.add_edge('B', 'D', resistance=4) # result of reducing B\u2013C\u2013D network G2_step1_corrected.add_edge('D', 'E', resistance=3) # Step 2: Final reduction to A\u2013E G2_final_corrected = nx.MultiGraph() G2_final_corrected.add_edge('A', 'E', resistance=10) # Reuse draw_combined_steps function draw_combined_steps( G2_step1_corrected, G2_final_corrected, [\"Step 1: B\u2013C\u2013D Triangle Reduced\", \"Step 2: Final Equivalent\"], \"example2_corrected_combined_steps\" ) Example 3: Complex Circuit with Multiple Loops Click to Expand Visual's Code # Define graph structure G3 = nx.MultiGraph() G3.add_edge('A', 'B', resistance=2) G3.add_edge('B', 'C', resistance=4) G3.add_edge('A', 'C', resistance=6) G3.add_edge('C', 'D', resistance=3) G3.add_edge('D', 'E', resistance=5) G3.add_edge('C', 'E', resistance=15) # Visualization function def draw_multigraph_as_simple(G_multi, title, filename): G_simple = nx.Graph() for u, v, data in G_multi.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels) plt.title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Draw graph draw_multigraph_as_simple(G3, \"Example 3: Complex Circuit with Loops\", \"example3_graph\") Circuit: A\u2013B = 2 \u03a9 B\u2013C = 4 \u03a9 A\u2013C = 6 \u03a9 C\u2013D = 3 \u03a9 D\u2013E = 5 \u03a9 C\u2013E = 15 \u03a9 Interpretation: A\u2013B\u2013C is in series (2 + 4 = 6 \u03a9), in parallel with direct A\u2013C (6 \u03a9) \u2192 A\u2013C total: 3 \u03a9 C\u2013D\u2013E (3 + 5 = 8 \u03a9), in parallel with C\u2013E (15 \u03a9) \u2192 C\u2013E total: \\( \\frac{1}{8} + \\frac{1}{15} \\) \u2192 ~5.22 \u03a9 Final total path A\u2013C\u2013E: 3 + 5.22 \u2248 8.22 \u03a9 Example 3 \u2013 Step-by-Step Simplification: Fig. : Left: The parallel paths A\u2013B\u2013C with A\u2013C, and C\u2013D\u2013E with C\u2013E, are reduced to single resistors. Fig. : Right: The simplified A\u2013C\u2013E path becomes one equivalent edge between A and E, completing the circuit reduction. Click to Expand Example 3: Step-by-Step Simplification Code ```python # Step-by-step graph structures G3_step1 = nx.MultiGraph() G3_step1.add_edge('A', 'C', resistance=3) # result of A\u2013B\u2013C || A\u2013C G3_step1.add_edge('C', 'E', resistance=5.22) # result of C\u2013D\u2013E || C\u2013E G3_final = nx.MultiGraph() G3_final.add_edge('A', 'E', resistance=8.22) # final equivalent # Reuse draw_combined_steps() from earlier # Draw and save combined figure draw_combined_steps(G3_step1, G3_final, [\"Step 1: Parallel Groups Collapsed\", \"Step 2: Final Equivalent\"], \"example3_combined_steps\") Conclusion This project demonstrated how graph theory can simplify the analysis of electrical circuits by reducing complex resistor networks to a single equivalent resistance. Through step-by-step simplification of series and parallel combinations, we showed that graph-based methods provide a structured, visual, and automatable approach to circuit reduction. Efficiency and Limitations The implemented method uses iterative detection of series and parallel resistor patterns. It performs well for small to medium-sized circuits and converges quickly in most practical cases. Computational Efficiency: Each iteration runs in \\( O(n + m) \\) , where \\( n \\) is the number of nodes and \\( m \\) is the number of edges. Limitations: The algorithm currently supports only resistive components and cannot simplify bridge networks or circuits containing voltage/current sources. Possible Extensions: The approach could be enhanced with support for star-delta (Y\u2013\u0394) transformations, additional circuit elements, and a graphical interface for interactive analysis.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating the equivalent resistance of a circuit is essential for understanding current flow and energy use. Traditional methods become complex with large circuits, especially when combinations of series and parallel resistors are nested.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#implementation-strategy","text":"We represent the circuit as a weighted graph using a MultiGraph structure, where: Each node is a junction in the circuit. Each edge is a resistor, with its resistance stored as an edge weight. The simplification algorithm works by: Identifying parallel resistors \u2014 multiple edges between the same two nodes \u2014 and replacing them with one equivalent edge using: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum \\frac{1}{R_i} \\] Identifying series resistors \u2014 paths through intermediate nodes of degree 2 \u2014 and collapsing them into a single resistor using: $$ R_{\\text{eq}} = R_1 + R_2 + \\dots $$ This process repeats iteratively until the graph reduces to a single equivalent resistor between the input and output terminals.","title":"Implementation Strategy"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"We implement the algorithm using the networkx library. The graph is simplified by: Merging parallel edges into one equivalent resistor. Collapsing series paths through non-terminal nodes. The algorithm continues until no further reductions can be made. Click to Expand Python Implementation ```python import networkx as nx def simplify_circuit(G, start, end): G = G.copy() while True: changed = False # Merge parallel resistors for u, v in list(G.edges()): keys = list(G[u][v].keys()) if len(keys) > 1: resistances = [G[u][v][k]['resistance'] for k in keys] R_parallel = 1 / sum(1 / R for R in resistances) G.remove_edges_from([(u, v, k) for k in keys]) G.add_edge(u, v, resistance=R_parallel) changed = True break # restart after modification if changed: continue # Collapse series nodes for node in list(G.nodes()): if node in (start, end) or G.degree(node) != 2: continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: edge1 = list(G.get_edge_data(node, neighbors[0]).values())[0] edge2 = list(G.get_edge_data(node, neighbors[1]).values())[0] R_series = edge1['resistance'] + edge2['resistance'] G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], resistance=R_series) changed = True break if not changed: break # Return result if G.has_edge(start, end): return list(G.get_edge_data(start, end).values())[0]['resistance'] else: return float('inf') # no path","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-mixed-series-and-parallel-resistors","text":"Click to Expand Visual's Code ```python # Define graph structure G1 = nx.MultiGraph() G1.add_edge('A', 'B', resistance=4) G1.add_edge('B', 'C', resistance=6) G1.add_edge('A', 'C', resistance=12) # Visualization function def draw_multigraph_as_simple(G_multi, title, filename): G_simple = nx.Graph() for u, v, data in G_multi.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels) plt.title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Draw graph draw_multigraph_as_simple(G1, \"Example 1: Mixed Series and Parallel\", \"example1_graph_fixed\") Circuit: A\u2013B\u2013C is a series path: - A\u2013B = 4 \u03a9 - B\u2013C = 6 \u03a9 A direct A\u2013C path also exists: - A\u2013C = 12 \u03a9 Interpretation: The 4 \u03a9 and 6 \u03a9 are in series \u2192 10 \u03a9 This 10 \u03a9 is in parallel with 12 \u03a9 Expected Result: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{10} + \\frac{1}{12} \\Rightarrow R_{\\text{eq}} \\approx 5.45\\ \\Omega \\] Example 1: Step-by-Step Simplification: Fig. : Left: After collapsing the A\u2013B\u2013C series path into a single 10 \u03a9 edge, the circuit includes two parallel resistors between A and C. Fig. : Right: These are then reduced to one equivalent resistor of 5.45 \u03a9, completing the simplification. Click to Expand Example 1: Step-by-Step Simplification Code ```python # Define both graphs G_step1 = nx.MultiGraph() G_step1.add_edge('A', 'C', resistance=10) G_step1.add_edge('A', 'C', resistance=12) G_final = nx.MultiGraph() G_final.add_edge('A', 'C', resistance=5.45) # Visualization function def draw_combined_steps(G1, G2, titles, filename): fig, axes = plt.subplots(1, 2, figsize=(12, 5)) for ax, G, title in zip(axes, [G1, G2], titles): G_simple = nx.Graph() for u, v, data in G.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold', ax=ax) nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels, ax=ax) ax.set_title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Create and save combined figure draw_combined_steps(G_step1, G_final, [\"Step 1: Series Collapsed\", \"Step 2: Final Equivalent\"], \"example1_combined_steps\")","title":"Example 1: Mixed Series and Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-nested-series-and-parallel-configuration","text":"Click to Expand Visual's Code ```python # Define graph structure G2 = nx.MultiGraph() G2.add_edge('A', 'B', resistance=3) G2.add_edge('B', 'C', resistance=6) G2.add_edge('B', 'D', resistance=6) G2.add_edge('C', 'D', resistance=6) G2.add_edge('D', 'E', resistance=3) # Visualization function def draw_multigraph_as_simple(G_multi, title, filename): G_simple = nx.Graph() for u, v, data in G_multi.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels) plt.title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Draw graph draw_multigraph_as_simple(G2, \"Example 2: Nested Series and Parallel\", \"example2_graph\") Circuit: A\u2013B = 3 \u03a9 B\u2013C = 6 \u03a9 B\u2013D = 6 \u03a9 C\u2013D = 6 \u03a9 D\u2013E = 3 \u03a9 Interpretation: Nodes C and D form a parallel pair (6 \u03a9 || 6 \u03a9 = 3 \u03a9) B\u2013(C,D)\u2013E becomes a series chain : 6 + 3 + 3 = 12 \u03a9 Final path A\u2013B\u2013(C,D)\u2013D\u2013E = 3 + 12 = 15 \u03a9 Example 2 \u2013 Step-by-Step Simplification: Fig. : Left: The triangular B\u2013C\u2013D configuration is reduced to a single 4 \u03a9 equivalent resistor between B and D. Fig. : Right: The resulting A\u2013B\u2013D\u2013E path (3 + 4 + 3) is simplified into one 10 \u03a9 resistor between A and E. Click to Expand Example 2: Step-by-Step Simplification Code ```python # Step 1: Triangle B\u2013C\u2013D reduced G2_step1_corrected = nx.MultiGraph() G2_step1_corrected.add_edge('A', 'B', resistance=3) G2_step1_corrected.add_edge('B', 'D', resistance=4) # result of reducing B\u2013C\u2013D network G2_step1_corrected.add_edge('D', 'E', resistance=3) # Step 2: Final reduction to A\u2013E G2_final_corrected = nx.MultiGraph() G2_final_corrected.add_edge('A', 'E', resistance=10) # Reuse draw_combined_steps function draw_combined_steps( G2_step1_corrected, G2_final_corrected, [\"Step 1: B\u2013C\u2013D Triangle Reduced\", \"Step 2: Final Equivalent\"], \"example2_corrected_combined_steps\" )","title":"Example 2: Nested Series and Parallel Configuration"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-complex-circuit-with-multiple-loops","text":"Click to Expand Visual's Code # Define graph structure G3 = nx.MultiGraph() G3.add_edge('A', 'B', resistance=2) G3.add_edge('B', 'C', resistance=4) G3.add_edge('A', 'C', resistance=6) G3.add_edge('C', 'D', resistance=3) G3.add_edge('D', 'E', resistance=5) G3.add_edge('C', 'E', resistance=15) # Visualization function def draw_multigraph_as_simple(G_multi, title, filename): G_simple = nx.Graph() for u, v, data in G_multi.edges(data=True): if G_simple.has_edge(u, v): existing = G_simple[u][v]['label'] G_simple[u][v]['label'] = f\"{existing} || {data['resistance']}\" else: G_simple.add_edge(u, v, label=str(data['resistance'])) pos = nx.spring_layout(G_simple, seed=42) edge_labels = nx.get_edge_attributes(G_simple, 'label') nx.draw(G_simple, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G_simple, pos, edge_labels=edge_labels) plt.title(title) plt.tight_layout() plt.savefig(f\"{filename}.png\") plt.close() # Draw graph draw_multigraph_as_simple(G3, \"Example 3: Complex Circuit with Loops\", \"example3_graph\") Circuit: A\u2013B = 2 \u03a9 B\u2013C = 4 \u03a9 A\u2013C = 6 \u03a9 C\u2013D = 3 \u03a9 D\u2013E = 5 \u03a9 C\u2013E = 15 \u03a9 Interpretation: A\u2013B\u2013C is in series (2 + 4 = 6 \u03a9), in parallel with direct A\u2013C (6 \u03a9) \u2192 A\u2013C total: 3 \u03a9 C\u2013D\u2013E (3 + 5 = 8 \u03a9), in parallel with C\u2013E (15 \u03a9) \u2192 C\u2013E total: \\( \\frac{1}{8} + \\frac{1}{15} \\) \u2192 ~5.22 \u03a9 Final total path A\u2013C\u2013E: 3 + 5.22 \u2248 8.22 \u03a9 Example 3 \u2013 Step-by-Step Simplification: Fig. : Left: The parallel paths A\u2013B\u2013C with A\u2013C, and C\u2013D\u2013E with C\u2013E, are reduced to single resistors. Fig. : Right: The simplified A\u2013C\u2013E path becomes one equivalent edge between A and E, completing the circuit reduction. Click to Expand Example 3: Step-by-Step Simplification Code ```python # Step-by-step graph structures G3_step1 = nx.MultiGraph() G3_step1.add_edge('A', 'C', resistance=3) # result of A\u2013B\u2013C || A\u2013C G3_step1.add_edge('C', 'E', resistance=5.22) # result of C\u2013D\u2013E || C\u2013E G3_final = nx.MultiGraph() G3_final.add_edge('A', 'E', resistance=8.22) # final equivalent # Reuse draw_combined_steps() from earlier # Draw and save combined figure draw_combined_steps(G3_step1, G3_final, [\"Step 1: Parallel Groups Collapsed\", \"Step 2: Final Equivalent\"], \"example3_combined_steps\")","title":"Example 3: Complex Circuit with Multiple Loops"},{"location":"1%20Physics/5%20Circuits/Problem_1/#conclusion","text":"This project demonstrated how graph theory can simplify the analysis of electrical circuits by reducing complex resistor networks to a single equivalent resistance. Through step-by-step simplification of series and parallel combinations, we showed that graph-based methods provide a structured, visual, and automatable approach to circuit reduction.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/#efficiency-and-limitations","text":"The implemented method uses iterative detection of series and parallel resistor patterns. It performs well for small to medium-sized circuits and converges quickly in most practical cases. Computational Efficiency: Each iteration runs in \\( O(n + m) \\) , where \\( n \\) is the number of nodes and \\( m \\) is the number of edges. Limitations: The algorithm currently supports only resistive components and cannot simplify bridge networks or circuits containing voltage/current sources. Possible Extensions: The approach could be enhanced with support for star-delta (Y\u2013\u0394) transformations, additional circuit elements, and a graphical interface for interactive analysis.","title":"Efficiency and Limitations"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}